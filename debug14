-- [FishItHub v4.1 Ultimate] Complete Feature Set - FIXED
-- Game: Fisch üêü
-- Author: Komar x ChatGPT x Claude
-- Features: Smart AutoFish (FIXED), Rare Fish Filter, Island Teleports, Anti-AFK, Rod/Bait/Skin Spoof

print("[FishItHub] üîÑ Loading v4.1 Ultimate (FIXED)...")

-- ========== ENHANCED LOGGING SYSTEM ==========
local LOG_LEVELS = {DEBUG = 1, INFO = 2, WARN = 3, ERROR = 4, CRITICAL = 5}
local logHistory = {}
local MAX_LOG_HISTORY = 100
local currentLogLevel = LOG_LEVELS.DEBUG

local GuiLogDisplay = nil -- Will be set later for real-time logs

local function addToHistory(level, category, message)
    table.insert(logHistory, {
        timestamp = tick(),
        level = level,
        category = category,
        message = message,
        time = os.date("%H:%M:%S")
    })
    if #logHistory > MAX_LOG_HISTORY then table.remove(logHistory, 1) end
    
    -- Update GUI log display
    if GuiLogDisplay then
        task.spawn(function()
            pcall(function()
                local logText = ""
                for i = math.max(1, #logHistory - 20), #logHistory do
                    local log = logHistory[i]
                    local icon = "‚Ä¢"
                    if log.level == LOG_LEVELS.ERROR then icon = "‚ùå"
                    elseif log.level == LOG_LEVELS.WARN then icon = "‚ö†Ô∏è"
                    elseif log.level == LOG_LEVELS.INFO then icon = "‚ÑπÔ∏è"
                    elseif log.level == LOG_LEVELS.DEBUG then icon = "üîç" end
                    
                    logText = logText .. string.format("[%s] %s [%s] %s\n", 
                        log.time, icon, log.category, log.message)
                end
                GuiLogDisplay.Text = logText
            end)
        end)
    end
end

local function safeConcat(...)
    local args = {...}
    local result = {}
    for i, v in ipairs(args) do
        table.insert(result, tostring(v))
    end
    return table.concat(result, " ")
end

local function log(level, category, ...)
    if level < currentLogLevel then return end
    local message = safeConcat(...)
    local prefix = "[FishItHub]["..category.."]"
    addToHistory(level, category, message)
    
    if level == LOG_LEVELS.DEBUG then print(prefix, "üîç", message)
    elseif level == LOG_LEVELS.INFO then print(prefix, "‚ÑπÔ∏è", message)
    elseif level == LOG_LEVELS.WARN then warn(prefix, "‚ö†Ô∏è", message)
    elseif level == LOG_LEVELS.ERROR then warn(prefix, "‚ùå", message)
    elseif level == LOG_LEVELS.CRITICAL then warn(prefix, "üî• CRITICAL:", message) end
end

local function logInfo(cat, ...) log(LOG_LEVELS.INFO, cat, ...) end
local function logWarn(cat, ...) log(LOG_LEVELS.WARN, cat, ...) end
local function logError(cat, ...) log(LOG_LEVELS.ERROR, cat, ...) end
local function logDebug(cat, ...) log(LOG_LEVELS.DEBUG, cat, ...) end

-- Performance Tracker
local perfTracker = {}
local function perfStart(name)
    perfTracker[name] = {start = tick(), count = (perfTracker[name] and perfTracker[name].count or 0) + 1}
end
local function perfEnd(name)
    if not perfTracker[name] then return end
    local elapsed = tick() - perfTracker[name].start
    perfTracker[name].lastDuration = elapsed
    perfTracker[name].totalTime = (perfTracker[name].totalTime or 0) + elapsed
    if elapsed > 5 then logWarn("PERF", name, "SLOW:", string.format("%.2f", elapsed).."s") end
    return elapsed
end

-- Statistics
local stats = {
    fishCaught = 0,
    rareCaught = 0,
    totalCycles = 0,
    errorCount = {fishing = 0, selling = 0, teleport = 0, init = 0},
    lastError = {},
    rareFish = {}
}

-- üß© Load Library (Using Orion for better input support)
perfStart("LoadLibrary")
local OrionLib
local success = pcall(function()
    OrionLib = loadstring(game:HttpGet('https://raw.githubusercontent.com/shlexware/Orion/main/source'))()
end)
perfEnd("LoadLibrary")

if not success or not OrionLib then
    logError("INIT", "Failed to load Orion library, trying fallback...")
    -- Fallback to ProjectMadara if Orion fails
    success = pcall(function()
        OrionLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/idonthaveoneatm/Libraries/normal/quake/src"))()
    end)
    if not success then
        logError("INIT", "All libraries failed to load")
        return
    end
end
logInfo("INIT", "‚úÖ Library loaded")

-- ü™ü Create GUI (Using Orion)
local Window = OrionLib:MakeWindow({
    Name = "FishItHub v4.1 Ultimate",
    HidePremium = false,
    SaveConfig = true,
    ConfigFolder = "FishItHub"
})

if not Window then
    logError("INIT", "Failed to create window")
    return
end

-- üóÇÔ∏è Create Tabs
local TabFishing = Window:MakeTab({Name = "üé£ Fishing", Icon = "rbxassetid://4483345998", PremiumOnly = false})
local TabSelling = Window:MakeTab({Name = "üí∞ Selling", Icon = "rbxassetid://4483345998", PremiumOnly = false})
local TabTravel = Window:MakeTab({Name = "üó∫Ô∏è Travel", Icon = "rbxassetid://4483345998", PremiumOnly = false})
local TabSpoof = Window:MakeTab({Name = "üé≠ Spoof", Icon = "rbxassetid://4483345998", PremiumOnly = false})
local TabStability = Window:MakeTab({Name = "üõ°Ô∏è Stability", Icon = "rbxassetid://4483345998", PremiumOnly = false})
local TabDebug = Window:MakeTab({Name = "üêõ Debug", Icon = "rbxassetid://4483345998", PremiumOnly = false})

logInfo("GUI", "‚úÖ All tabs created")

-- üåê Find Remotes
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local net

pcall(function()
    net = ReplicatedStorage:WaitForChild("Packages", 5)
        :WaitForChild("_Index", 5)
        :WaitForChild("sleitnick_net@0.2.0", 5)
        :WaitForChild("net", 5)
end)

if not net then
    local pk = ReplicatedStorage:FindFirstChild("Packages")
    if pk then
        local idx = pk:FindFirstChild("_Index")
        if idx then
            for _, v in ipairs(idx:GetChildren()) do
                if string.find(v.Name, "sleitnick_net") then
                    net = v:FindFirstChild("net")
                    if net then break end
                end
            end
        end
    end
end

if not net then
    logError("NET", "Cannot find net folder")
    return
end

logInfo("NET", "‚úÖ Found net folder")

-- üéØ Get Remotes
local function getRemote(name)
    local found = net:FindFirstChild(name, true)
    if found then logInfo("REMOTE", "‚úÖ", name)
    else logWarn("REMOTE", "‚ö†Ô∏è Missing:", name) end
    return found
end

local RF_Charge = getRemote("RF/ChargeFishingRod")
local RF_RequestMini = getRemote("RF/RequestFishingMinigameStarted")
local RE_Completed = getRemote("RE/FishingCompleted")
local RE_EquipTool = getRemote("RE/EquipToolFromHotbar")
local RF_SellAll = getRemote("RF/SellAllItems")
local RE_EquipRod = getRemote("RE/EquipItem")
local RE_EquipBait = getRemote("RE/EquipBait")
local RE_EquipRodSkin = getRemote("RE/EquipRodSkin")
local RE_FishCaught = getRemote("RE/FishCaught")

-- ========== FISH CATEGORIES DATABASE ==========
local FISH_DATABASE = {
    Secret = {
        "Crystal Crab", "Orca", "Megalodon", "Worm Fish", "Ghost Shark",
        "Lochness Monster", "Monster Shark", "Eerie Shark", "Armored Shark",
        "Great Whale", "Kraken", "Queen Crab", "Robot Kraken", "King Crab",
        "Giant Squid", "Panther Eel"
    },
    Mythic = {
        "Dotted Stingray", "Manta Ray", "Hammerhead Shark", "Swordfish Shark",
        "Loggerhead Turtle", "Prismy Seahorse", "Blueflame Ray", "Magma Shark",
        "Hawks Turtle", "Abyss Seahorse", "Brown Megalodon", "Thresher Shark",
        "Blob Fish"
    },
    Legendary = {
        "Lined Cardinal Fish", "Yellowfish Tuna", "Chrome Tuna", "Bumblebee Grouper",
        "Lobster", "Lavafin Tuna", "Starjam Tang", "Greenbee Grouper",
        "Blue Lobster", "Enchanted Angelfish", "Magic Tang", "Axolotl",
        "Deep Sea Crab"
    },
    Epic = {
        "Dorhey Tang", "Unicorn Tang", "Cow Clownfish", "Moorish Idol",
        "Sushi Cardinal", "Longnose Butterfly", "Firecoal Damsel", "Panther Grouper",
        "Domino Damsel", "Astra Damsel", "Pufferfish", "Vampire Squid",
        "Angler Fish"
    },
    Rare = {
        "Barracuda Fish", "Korean Angelfish", "Ballina Angelfish", "Frog",
        "Darwin Clownfish", "Jewel Tang", "Candy Butterfly", "Fire Goby",
        "Kau Cardinal", "Rockform Cardianl", "Volsail Tang", "White Clownfish",
        "Scissortail Dartfish", "Charmed Tang", "Catfish", "Sheepshead Fish",
        "Coney Fish", "Jellyfish"
    }
}

-- ========== STATE ==========
local state = {
    autoFishing = false,
    autoSell = false,
    antiAFK = false,
    filterRare = {
        Secret = false,
        Mythic = false,
        Legendary = false,
        Epic = false,
        Rare = false
    },
    fishingThread = nil,
    lastFishingSpot = nil,
    playerTeleportUsername = "",
    spoofRod = "Ghostfinn Rod",
    spoofBait = "Singularity Bait",
    spoofSkin = "Default",
    enableSpoof = false,
    lastActivity = tick()
}

-- ========== RARE FISH DETECTION ==========
local function getFishTier(fishName)
    if not fishName then return nil end
    local fishStr = tostring(fishName)
    
    for tier, fishList in pairs(FISH_DATABASE) do
        for _, fish in ipairs(fishList) do
            if fishStr == fish or string.lower(fishStr) == string.lower(fish) then
                return tier
            end
        end
    end
    
    return nil
end

local function alertRareCatch(fishName, tier)
    stats.rareCaught = stats.rareCaught + 1
    table.insert(stats.rareFish, {name = fishName, tier = tier, time = os.date("%H:%M:%S")})
    logInfo("RARE", "üåüüåüüåü RARE CATCH:", fishName, "["..tier.."]", "üåüüåüüåü")
    
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "üåü RARE FISH!",
        Text = fishName .. " [" .. tier .. "]",
        Duration = 5
    })
end

-- ========== ROD/BAIT/SKIN SPOOF SYSTEM ==========
local function applyFullSpoof()
    if not state.enableSpoof then return end
    
    logInfo("SPOOF", "üé≠ Applying full equipment spoof...")
    
    -- Spoof Rod
    pcall(function()
        if RE_EquipRod then
            RE_EquipRod:FireServer(state.spoofRod)
            logInfo("SPOOF", "‚úÖ Rod equipped:", state.spoofRod)
        end
    end)
    task.wait(0.1)
    
    -- Spoof Bait
    pcall(function()
        if RE_EquipBait then
            RE_EquipBait:FireServer(state.spoofBait)
            logInfo("SPOOF", "‚úÖ Bait equipped:", state.spoofBait)
        end
    end)
    task.wait(0.1)
    
    -- Spoof Skin (if not Default)
    if state.spoofSkin ~= "Default" then
        pcall(function()
            if RE_EquipRodSkin then
                RE_EquipRodSkin:FireServer(state.spoofSkin)
                logInfo("SPOOF", "‚úÖ Skin equipped:", state.spoofSkin)
            end
        end)
        task.wait(0.1)
    end
    
    logInfo("SPOOF", "‚úÖ All equipment spoofed successfully!")
end

-- ========== FISHING LOGIC (COMPLETELY FIXED) ==========
local function startFishing()
    if state.fishingThread then 
        logWarn("FISHING", "Already running")
        return 
    end
    
    logInfo("FISHING", "üé£ Starting Auto Fishing (Ultra Fixed Mode)...")
    
    -- Apply spoof before starting
    if state.enableSpoof then
        applyFullSpoof()
    end
    
    state.fishingThread = task.spawn(function()
        local cycleCount = 0
        
        while state.autoFishing do
            cycleCount = cycleCount + 1
            stats.totalCycles = cycleCount
            perfStart("Cycle_"..cycleCount)
            
            logDebug("FISHING", "=== CYCLE", cycleCount, "START ===")
            
            local ok, err = pcall(function()
                -- Critical timings for successful catch
                local EQUIP_DELAY = 0.15
                local CHARGE_DELAY = 0.25
                local CAST_WAIT = 0.4
                local BITE_WAIT = 3.5  -- Wait for fish to bite (CRITICAL)
                local CATCH_DELAY = 0.3
                local REST_DELAY = 1.5
                
                -- Save position
                local player = game.Players.LocalPlayer
                if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    state.lastFishingSpot = player.Character.HumanoidRootPart.CFrame
                end
                
                -- STEP 1: Equip Rod
                logDebug("FISHING", "Step 1/4: Equipping rod...")
                if RE_EquipTool then
                    RE_EquipTool:FireServer(1)
                    task.wait(EQUIP_DELAY)
                    logDebug("FISHING", "‚úì Rod equipped")
                end

                -- STEP 2: Charge & Cast
                logDebug("FISHING", "Step 2/4: Charging & casting...")
                if RF_Charge then
                    local chargeOk = pcall(function()
                        RF_Charge:InvokeServer(workspace:GetServerTimeNow())
                    end)
                    if chargeOk then
                        logDebug("FISHING", "‚úì Rod charged & cast")
                    else
                        logWarn("FISHING", "‚ö†Ô∏è Charge failed, continuing...")
                    end
                    task.wait(CHARGE_DELAY)
                end

                -- STEP 3: Wait for bite + Request Minigame
                logDebug("FISHING", "Step 3/4: Waiting for fish to bite...")
                task.wait(CAST_WAIT)
                
                if RF_RequestMini then
                    local miniOk = pcall(function()
                        RF_RequestMini:InvokeServer(-1.2, 1)
                    end)
                    if miniOk then
                        logDebug("FISHING", "‚úì Minigame requested")
                    else
                        logWarn("FISHING", "‚ö†Ô∏è Minigame request failed")
                    end
                end
                
                -- CRITICAL: Wait for fish to bite before completing
                logDebug("FISHING", "‚è≥ Waiting for bite (3.5s)...")
                task.wait(BITE_WAIT)

                -- STEP 4: Complete the catch (FIX FOR STUCK ISSUE)
                logDebug("FISHING", "Step 4/4: Catching fish...")
                if RE_Completed then
                    local completeOk = pcall(function()
                        RE_Completed:FireServer()
                    end)
                    if completeOk then
                        stats.fishCaught = stats.fishCaught + 1
                        logInfo("FISHING", "‚úÖ FISH CAUGHT! Total:", stats.fishCaught)
                    else
                        logWarn("FISHING", "‚ö†Ô∏è Complete failed")
                    end
                    task.wait(CATCH_DELAY)
                end
                
                -- Rest between cycles
                logDebug("FISHING", "üí§ Resting before next cast...")
                task.wait(REST_DELAY)
                
                state.lastActivity = tick()
            end)
            
            local duration = perfEnd("Cycle_"..cycleCount)
            
            if not ok then
                logError("FISHING", "‚ùå Cycle", cycleCount, "error:", tostring(err))
                stats.errorCount.fishing = stats.errorCount.fishing + 1
                task.wait(3)
            else
                logDebug("FISHING", "=== CYCLE", cycleCount, "COMPLETE ===", string.format("%.2fs", duration or 0))
            end
        end
        
        logInfo("FISHING", "‚õî Stopped after", cycleCount, "cycles")
        state.fishingThread = nil
    end)
end

-- ========== SELLING LOGIC ==========
local function sellFish(manual)
    perfStart("Sell")
    
    local player = game.Players.LocalPlayer
    if not player then return end
    
    local protectedFish = {}
    pcall(function()
        local backpack = player:FindFirstChild("Backpack")
        if backpack then
            for _, item in ipairs(backpack:GetChildren()) do
                local tier = getFishTier(item.Name)
                if tier and state.filterRare[tier] then
                    table.insert(protectedFish, {name = item.Name, tier = tier})
                end
            end
        end
    end)
    
    if #protectedFish == 0 then
        if RF_SellAll then
            local ok, res = pcall(function()
                return RF_SellAll:InvokeServer()
            end)
            if ok then
                logInfo("SELL", "‚úÖ Sold fish", manual and "(Manual)" or "(Auto)")
            else
                logError("SELL", "Failed:", tostring(res))
            end
        end
    else
        logInfo("SELL", "Skipped - Protected fish:")
        for _, fish in ipairs(protectedFish) do
            logInfo("SELL", " -", fish.name, "["..fish.tier.."]")
        end
    end
    
    perfEnd("Sell")
end

-- ========== TELEPORT LOCATIONS ==========
local NPCS_ORDER = {
    {name = "Rods Here!", pos = Vector3.new(146.81, 20.47, 2837.95)},
    {name = "Bobbers", pos = Vector3.new(103.67, 17.28, 2867.04)},
    {name = "Skin Crates", pos = Vector3.new(78.28, 17.28, 2865.28)},
    {name = "Sell Here!", pos = Vector3.new(44.10, 17.28, 2867.51)},
    {name = "Utility Store", pos = Vector3.new(-43.83, 20.46, 2874.31)},
    {name = "Traveling Merchant", pos = Vector3.new(-128.38, 2.58, 2767.39)}
}

local ISLANDS_ORDER = {
    {name = "Fisherman Island", pos = Vector3.new(122.96, 3.37, 2784.57)},
    {name = "Ancient Jungle", pos = Vector3.new(1235.60, 7.97, -123.50)},
    {name = "Lost Isle", pos = Vector3.new(-3603.80, -2.66, -1310.98)},
    {name = "Esoteric Depths", pos = Vector3.new(2954.65, -1302.73, 1529.24)},
    {name = "Crater Island", pos = Vector3.new(993.45, 2.49, 5012.44)},
    {name = "Tropical Grove", pos = Vector3.new(-2049.86, 6.27, 3655.13)},
    {name = "Coral Reefs", pos = Vector3.new(-2730.52, 4.00, 2174.49)},
    {name = "Kohana Volcano", pos = Vector3.new(-598.58, 59.00, 108.43)}
}

local function teleportTo(position, name)
    perfStart("Teleport")
    local player = game.Players.LocalPlayer
    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local ok, err = pcall(function()
            player.Character.HumanoidRootPart.CFrame = CFrame.new(position)
        end)
        if ok then
            logInfo("TELEPORT", "‚úÖ Teleported to:", name)
        else
            logError("TELEPORT", "Failed:", tostring(err))
        end
    end
    perfEnd("Teleport")
end

local function teleportToPlayer(username)
    if not username or username == "" then
        logError("TELEPORT", "Username is empty")
        return
    end
    
    local targetPlayer = game.Players:FindFirstChild(username)
    
    if not targetPlayer then
        logError("TELEPORT", "Player not found:", username)
        OrionLib:MakeNotification({
            Name = "‚ö†Ô∏è Error",
            Content = "Player '" .. username .. "' not found!",
            Time = 3
        })
        return
    end
    
    if targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local player = game.Players.LocalPlayer
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            player.Character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame
            logInfo("TELEPORT", "‚úÖ Teleported to player:", username)
            OrionLib:MakeNotification({
                Name = "‚úÖ Success",
                Content = "Teleported to " .. username,
                Time = 3
            })
        end
    end
end

-- ========== ANTI-AFK SYSTEM ==========
local function startAntiAFK()
    task.spawn(function()
        while state.antiAFK do
            local player = game.Players.LocalPlayer
            if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = player.Character.HumanoidRootPart
                local randomOffset = Vector3.new(math.random(-2, 2), 0, math.random(-2, 2))
                hrp.CFrame = hrp.CFrame + randomOffset
            end
            task.wait(math.random(45, 90))
        end
    end)
    logInfo("STABILITY", "‚úÖ Anti-AFK enabled")
end

-- ========== EMERGENCY RESET ==========
local function emergencyReset()
    logWarn("RESET", "üö® EMERGENCY RESET TRIGGERED")
    
    state.autoFishing = false
    state.autoSell = false
    state.antiAFK = false
    state.enableSpoof = false
    
    task.wait(0.5)
    
    stats.fishCaught = 0
    stats.rareCaught = 0
    stats.totalCycles = 0
    stats.rareFish = {}
    
    logInfo("RESET", "‚úÖ All systems stopped and stats cleared")
    
    OrionLib:MakeNotification({
        Name = "üö® Emergency Reset",
        Content = "All systems stopped!",
        Time = 3
    })
end

-- ========== GUI: FISHING TAB ==========
local FishingSection = TabFishing:AddSection({Name = "üé£ Auto Fishing (Ultra Fixed)"})

TabFishing:AddToggle({
    Name = "Enable Auto Fishing",
    Default = false,
    Callback = function(v)
        state.autoFishing = v
        logInfo("GUI", "Auto Fishing:", tostring(v))
        if v then startFishing() end
    end
})

TabFishing:AddLabel("‚ö° Fixed timing system - no more stuck!")
TabFishing:AddLabel("üêü Catches: 0")

local fishCountLabel = TabFishing:AddLabel("üìä Total Cycles: 0")

-- Update stats in real-time
task.spawn(function()
    while task.wait(2) do
        pcall(function()
            fishCountLabel:Set("üêü Catches: " .. stats.fishCaught .. " | üåü Rare: " .. stats.rareCaught .. " | üìä Cycles: " .. stats.totalCycles)
        end)
    end
end)

-- ========== GUI: SELLING TAB ==========
local SellSection = TabSelling:AddSection({Name = "üí∞ Smart Selling System"})

TabSelling:AddLabel("üõ°Ô∏è Filter Fish (Don't Sell)")

TabSelling:AddToggle({Name = "‚òê Secret", Default = false, Callback = function(v) state.filterRare.Secret = v end})
TabSelling:AddToggle({Name = "‚òê Mythic", Default = false, Callback = function(v) state.filterRare.Mythic = v end})
TabSelling:AddToggle({Name = "‚òê Legendary", Default = false, Callback = function(v) state.filterRare.Legendary = v end})
TabSelling:AddToggle({Name = "‚òê Epic", Default = false, Callback = function(v) state.filterRare.Epic = v end})
TabSelling:AddToggle({Name = "‚òê Rare", Default = false, Callback = function(v) state.filterRare.Rare = v end})

TabSelling:AddButton({Name = "üíµ Manual Sell (Safe)", Callback = function() sellFish(true) end})

TabSelling:AddToggle({
    Name = "Auto Sell Every 30s",
    Default = false,
    Callback = function(v)
        state.autoSell = v
        if v then
            task.spawn(function()
                while state.autoSell do
                    task.wait(30)
                    if state.autoSell then sellFish(false) end
                end
            end)
        end
    end
})

-- ========== GUI: TRAVEL TAB ==========
local NPCSection = TabTravel:AddSection({Name = "üè™ Fishing Merchants"})

for _, npc in ipairs(NPCS_ORDER) do
    TabTravel:AddButton({
        Name = "‚Üí " .. npc.name,
        Callback = function() teleportTo(npc.pos, npc.name) end
    })
end

local IslandSection = TabTravel:AddSection({Name = "üó∫Ô∏è Island Teleports"})

for _, island in ipairs(ISLANDS_ORDER) do
    TabTravel:AddButton({
        Name = "üèùÔ∏è " .. island.name,
        Callback = function() teleportTo(island.pos, island.name) end
    })
end

local PlayerSection = TabTravel:AddSection({Name = "üë§ Teleport to Player"})

TabTravel:AddTextbox({
    Name = "Player Username",
    Default = "",
    TextDisappear = false,
    Callback = function(text)
        state.playerTeleportUsername = text
        logInfo("GUI", "Username set:", text)
    end
})

TabTravel:AddButton({
    Name = "üöÄ Teleport to Player",
    Callback = function()
        if state.playerTeleportUsername ~= "" then
            teleportToPlayer(state.playerTeleportUsername)
        else
            OrionLib:MakeNotification({
                Name = "‚ö†Ô∏è Warning",
                Content = "Please enter a username first!",
                Time = 3
            })
        end
    end
})

-- ========== GUI: SPOOF TAB ==========
local SpoofSection = TabSpoof:AddSection({Name = "üé≠ Equipment Spoof System"})

TabSpoof:AddLabel("‚ú® Get effects without owning items!")

TabSpoof:AddToggle({
    Name = "Enable Full Spoof",
    Default = false,
    Callback = function(v)
        state.enableSpoof = v
        logInfo("GUI", "Spoof enabled:", tostring(v))
        if v then
            applyFullSpoof()
            OrionLib:MakeNotification({
                Name = "üé≠ Spoof Activated",
                Content = "Equipment spoofed successfully!",
                Time = 3
            })
        end
    end
})

TabSpoof:AddDropdown({
    Name = "Select Rod",
    Default = "Ghostfinn Rod",
    Options = {"Ghostfinn Rod", "Rod of the Depths", "Trident Rod", "Kings Rod", "Mythical Rod", "No-Life Rod", "Fast Rod", "Lucky Rod", "Steady Rod", "Nocturnal Rod"},
    Callback = function(value)
        state.spoofRod = value
        logInfo("SPOOF", "Rod selected:", value)
        if state.enableSpoof then applyFullSpoof() end
    end
})

TabSpoof:AddDropdown({
    Name = "Select Bait",
    Default = "Singularity Bait",
    Options = {"Singularity Bait", "Night Shrimp", "Truffle Worm", "Minnow", "Squid", "Fish Head", "Worm", "Maggot", "Bagel", "Flakes", "Coral", "Deep Coral"},
    Callback = function(value)
        state.spoofBait = value
        logInfo("SPOOF", "Bait selected:", value)
        if state.enableSpoof then applyFullSpoof() end
    end
})

TabSpoof:AddDropdown({
    Name = "Select Rod Skin",
    Default = "Default",
    Options = {"Default", "Aurora Rod", "Candy Cane Rod", "Festive Rod", "Moonlight Rod", "Abyssal Rod", "Solar Rod"},
    Callback = function(value)
        state.spoofSkin = value
        logInfo("SPOOF", "Skin selected:", value)
        if state.enableSpoof then applyFullSpoof() end
    end
})

TabSpoof:AddButton({
    Name = "üîÑ Reapply Spoof Now",
    Callback = function()
        if state.enableSpoof then
            applyFullSpoof()
            OrionLib:MakeNotification({
                Name = "‚úÖ Spoof Applied",
                Content = "Equipment updated!",
                Time = 2
            })
        else
            OrionLib:MakeNotification({
                Name = "‚ö†Ô∏è Warning",
                Content = "Enable spoof first!",
                Time = 2
            })
        end
    end
})

TabSpoof:AddLabel("‚ÑπÔ∏è Spoof gives you all enchantments")
TabSpoof:AddLabel("‚ÑπÔ∏è Effects work in-game without ownership")

-- ========== GUI: STABILITY TAB ==========
local StabilitySection = TabStability:AddSection({Name = "üõ°Ô∏è Stability & Safety"})

TabStability:AddToggle({
    Name = "Anti-AFK Protection",
    Default = false,
    Callback = function(v)
        state.antiAFK = v
        if v then startAntiAFK() end
    end
})

TabStability:AddButton({
    Name = "üîÑ Restart Fishing",
    Callback = function()
        state.autoFishing = false
        task.wait(1)
        state.autoFishing = true
        startFishing()
        logInfo("STABILITY", "Fishing restarted")
        OrionLib:MakeNotification({
            Name = "üîÑ Restarted",
            Content = "Auto fishing restarted!",
            Time = 2
        })
    end
})

TabStability:AddButton({
    Name = "‚õî Emergency Stop All",
    Callback = function()
        state.autoFishing = false
        state.autoSell = false
        state.antiAFK = false
        logWarn("STABILITY", "üö® ALL SYSTEMS STOPPED")
        OrionLib:MakeNotification({
            Name = "‚õî STOPPED",
            Content = "All features disabled!",
            Time = 3
        })
    end
})

TabStability:AddButton({
    Name = "üö® Emergency Reset (Clear All)",
    Callback = function()
        emergencyReset()
    end
})

local ControlSection = TabStability:AddSection({Name = "üéõÔ∏è Menu Controls"})

TabStability:AddButton({
    Name = "üëÅÔ∏è Hide/Show Menu",
    Callback = function()
        OrionLib:Toggle()
        logInfo("GUI", "Menu visibility toggled")
    end
})

TabStability:AddButton({
    Name = "üóëÔ∏è Destroy Menu (Permanent)",
    Callback = function()
        emergencyReset()
        task.wait(0.5)
        OrionLib:Destroy()
        logInfo("GUI", "Menu destroyed")
    end
})

TabStability:AddLabel("‚ö†Ô∏è Destroy will close menu permanently")

-- ========== GUI: DEBUG TAB ==========
local DebugSection = TabDebug:AddSection({Name = "üêõ Real-Time Debug Logs"})

TabDebug:AddLabel("üìú Last 20 log entries:")

-- Create scrollable log display
local logDisplay = TabDebug:AddParagraph("Logs", "Waiting for logs...")
GuiLogDisplay = logDisplay -- Set global reference

-- Update initial log display
task.spawn(function()
    task.wait(1)
    if GuiLogDisplay then
        local logText = ""
        for i = math.max(1, #logHistory - 20), #logHistory do
            local log = logHistory[i]
            local icon = "‚Ä¢"
            if log.level == LOG_LEVELS.ERROR then icon = "‚ùå"
            elseif log.level == LOG_LEVELS.WARN then icon = "‚ö†Ô∏è"
            elseif log.level == LOG_LEVELS.INFO then icon = "‚ÑπÔ∏è"
            elseif log.level == LOG_LEVELS.DEBUG then icon = "üîç" end
            
            logText = logText .. string.format("[%s] %s [%s] %s\n", 
                log.time, icon, log.category, log.message)
        end
        GuiLogDisplay:Set({Title = "Debug Logs", Content = logText})
    end
end)

local StatsSection = TabDebug:AddSection({Name = "üìä Statistics"})

TabDebug:AddLabel("üêü Fish Caught: 0")
TabDebug:AddLabel("üåü Rare Caught: 0")
TabDebug:AddLabel("üìä Total Cycles: 0")
TabDebug:AddLabel("‚ùå Errors: 0")

local debugStats = {
    fishLabel = TabDebug:AddLabel("üêü Fish: 0"),
    rareLabel = TabDebug:AddLabel("üåü Rare: 0"),
    cycleLabel = TabDebug:AddLabel("üìä Cycles: 0"),
    errorLabel = TabDebug:AddLabel("‚ùå Errors: 0")
}

-- Update stats every 2 seconds
task.spawn(function()
    while task.wait(2) do
        pcall(function()
            local totalErrors = stats.errorCount.fishing + stats.errorCount.selling + stats.errorCount.teleport
            debugStats.fishLabel:Set("üêü Fish Caught: " .. stats.fishCaught)
            debugStats.rareLabel:Set("üåü Rare Caught: " .. stats.rareCaught)
            debugStats.cycleLabel:Set("üìä Total Cycles: " .. stats.totalCycles)
            debugStats.errorLabel:Set("‚ùå Total Errors: " .. totalErrors)
        end)
    end
end)

TabDebug:AddButton({
    Name = "üîÑ Refresh Logs",
    Callback = function()
        if GuiLogDisplay then
            local logText = ""
            for i = math.max(1, #logHistory - 20), #logHistory do
                local log = logHistory[i]
                local icon = "‚Ä¢"
                if log.level == LOG_LEVELS.ERROR then icon = "‚ùå"
                elseif log.level == LOG_LEVELS.WARN then icon = "‚ö†Ô∏è"
                elseif log.level == LOG_LEVELS.INFO then icon = "‚ÑπÔ∏è"
                elseif log.level == LOG_LEVELS.DEBUG then icon = "üîç" end
                
                logText = logText .. string.format("[%s] %s [%s] %s\n", 
                    log.time, icon, log.category, log.message)
            end
            GuiLogDisplay:Set({Title = "Debug Logs (Refreshed)", Content = logText})
        end
        OrionLib:MakeNotification({
            Name = "üîÑ Refreshed",
            Content = "Logs updated!",
            Time = 1
        })
    end
})

TabDebug:AddButton({
    Name = "üóëÔ∏è Clear Log History",
    Callback = function()
        logHistory = {}
        if GuiLogDisplay then
            GuiLogDisplay:Set({Title = "Debug Logs", Content = "[Logs cleared]"})
        end
        logInfo("DEBUG", "Log history cleared")
    end
})

local DebugControlSection = TabDebug:AddSection({Name = "üîß Debug Controls"})

TabDebug:AddDropdown({
    Name = "Log Level",
    Default = "DEBUG",
    Options = {"DEBUG", "INFO", "WARN", "ERROR"},
    Callback = function(value)
        if value == "DEBUG" then currentLogLevel = LOG_LEVELS.DEBUG
        elseif value == "INFO" then currentLogLevel = LOG_LEVELS.INFO
        elseif value == "WARN" then currentLogLevel = LOG_LEVELS.WARN
        elseif value == "ERROR" then currentLogLevel = LOG_LEVELS.ERROR end
        logInfo("DEBUG", "Log level changed to:", value)
    end
})

TabDebug:AddButton({
    Name = "üß™ Test Error Logging",
    Callback = function()
        logDebug("TEST", "This is a debug message")
        logInfo("TEST", "This is an info message")
        logWarn("TEST", "This is a warning message")
        logError("TEST", "This is an error message")
        OrionLib:MakeNotification({
            Name = "üß™ Test Complete",
            Content = "Check debug logs!",
            Time = 2
        })
    end
})

TabDebug:AddLabel("‚ÑπÔ∏è Logs update automatically")
TabDebug:AddLabel("‚ÑπÔ∏è Shows last 20 entries only")

-- ========== FISH CAUGHT EVENT LISTENER ==========
if RE_FishCaught then
    pcall(function()
        RE_FishCaught.OnClientEvent:Connect(function(fishData)
            if fishData and fishData.Name then
                local tier = getFishTier(fishData.Name)
                if tier then
                    alertRareCatch(fishData.Name, tier)
                end
            end
        end)
    end)
end

-- ========== PERFORMANCE MONITORING ==========
task.spawn(function()
    while task.wait(30) do
        pcall(function()
            local totalTime = 0
            local totalCalls = 0
            
            for name, data in pairs(perfTracker) do
                if data.totalTime then
                    totalTime = totalTime + data.totalTime
                    totalCalls = totalCalls + (data.count or 0)
                end
            end
            
            if totalCalls > 0 then
                logDebug("PERF", string.format("Avg operation time: %.3fs over %d calls", 
                    totalTime / totalCalls, totalCalls))
            end
        end)
    end
end)

-- ========== INITIALIZE ==========
logInfo("INIT", "‚úÖ‚úÖ‚úÖ FishItHub v4.1 Ultimate LOADED ‚úÖ‚úÖ‚úÖ")
logInfo("INIT", "üé£ All systems ready!")
logInfo("INIT", "üêõ Check Debug tab for real-time logs")
logInfo("INIT", "üé≠ Spoof tab for equipment spoofing")
logInfo("INIT", "üõ°Ô∏è Stability tab for controls & reset")

OrionLib:MakeNotification({
    Name = "‚úÖ FishItHub v4.1",
    Content = "Loaded successfully! Check Debug tab.",
    Time = 5
})

OrionLib:Init()

-- END OF SCRIPT
