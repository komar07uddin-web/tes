-- =========================================================================
-- FishItHub v3.5 Ultimate — Debug & Safe
-- Features included:
--   Auto Cast/Catch/Stop, Smart Timing, Catch Accuracy Modes,
--   Rare Catch Alert, Sell Summary Log, Auto Return to Spot,
--   Auto Sell When Full (threshold 5000) [best-effort],
--   Anti-AFK, Auto Reconnect/Retry, Heartbeat Watchdog, Safe Mode Toggle
-- GUI: ProjectMadara (quake)
-- =========================================================================

-- ========== Helpers & Safe API ==========
local Players        = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace      = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer    = Players.LocalPlayer

local function dbg(...) print("[FishItHub]", ...) end
local function warnDbg(...) warn("[FishItHub]", ...) end

-- safe load ProjectMadara UI
local ProjectMadara
local ok, err = pcall(function()
    ProjectMadara = loadstring(game:HttpGet("https://raw.githubusercontent.com/idonthaveoneatm/Libraries/normal/quake/src"))()
end)
if not ok or not ProjectMadara then
    warnDbg("Failed to load UI library:", err)
    return
end
dbg("UI library loaded")

-- ========= Adaptive net detection =========
local function findNet()
    local pk = ReplicatedStorage:FindFirstChild("Packages")
    if not pk then return nil end
    local idx = pk:FindFirstChild("_Index")
    if not idx then return nil end
    for _, v in ipairs(idx:GetChildren()) do
        if type(v.Name) == "string" and string.find(v.Name, "sleitnick_net") then
            local net = v:FindFirstChild("net")
            if net then return net end
        end
    end
    return nil
end

local net = findNet()
local tries = 0
while not net and tries < 15 do
    tries = tries + 1
    dbg("net not found, waiting... attempt", tries)
    wait(1)
    net = findNet()
end
if not net then
    warnDbg("Cannot locate sleitnick net package. Aborting.")
    return
end
dbg("Found net at", net:GetFullName())

-- determine RF/RE containers (some builds put remotes directly)
local rf = net:FindFirstChild("RF") or net
local re = net:FindFirstChild("RE") or net
dbg("Using RF container:", rf.Name, "RE container:", re.Name)

-- helper to find remote: try multiple naming patterns
local function findRemoteAny(name)
    -- try exact in RF/RE as provided by scan
    local r = rf:FindFirstChild(name)
    if r then return r end
    r = re:FindFirstChild(name)
    if r then return r end
    r = rf:FindFirstChild("RF/"..name)
    if r then return r end
    r = re:FindFirstChild("RE/"..name)
    if r then return r end
    -- try direct find in net descendants
    for _,v in ipairs(net:GetDescendants()) do
        if (v:IsA("RemoteFunction") or v:IsA("RemoteEvent")) and v.Name:lower():find(name:lower()) then
            return v
        end
    end
    return nil
end

local function safeInvoke(remote, ...)
    if not remote then return false, "remote nil" end
    local ok, res = pcall(function() return remote:InvokeServer(...) end)
    return ok, res
end
local function safeFire(remote, ...)
    if not remote then return false, "remote nil" end
    local ok, res = pcall(function() remote:FireServer(...) end)
    return ok, res
end

-- ========== REMOTES (based on your scan) ==========
local REMOTES = {
    ChargeFishingRod          = findRemoteAny("ChargeFishingRod"),             -- RF/ChargeFishingRod
    RequestFishingMinigameStarted = findRemoteAny("RequestFishingMinigameStarted"), -- RF/RequestFishingMinigameStarted
    FishingCompleted          = findRemoteAny("FishingCompleted"),            -- RE/FishingCompleted
    FishingMinigameChanged    = findRemoteAny("FishingMinigameChanged"),      -- RE/FishingMinigameChanged
    FishingStopped            = findRemoteAny("FishingStopped"),              -- RE/FishingStopped
    EquipToolFromHotbar       = findRemoteAny("EquipToolFromHotbar"),         -- RE/EquipToolFromHotbar
    EquipBait                 = findRemoteAny("EquipBait"),                  -- RE/EquipBait
    SellAllItems              = findRemoteAny("SellAllItems"),               -- RF/SellAllItems
    SellItem                  = findRemoteAny("SellItem"),                   -- RF/SellItem
    PurchaseBait              = findRemoteAny("PurchaseBait"),               -- RF/PurchaseBait
    PurchaseFishingRod        = findRemoteAny("PurchaseFishingRod"),         -- RF/PurchaseFishingRod
    SpawnBoat                 = findRemoteAny("SpawnBoat"),                  -- RF/SpawnBoat
    DespawnBoat               = findRemoteAny("DespawnBoat"),                -- RF/DespawnBoat
    UpdateAutoFishingState    = findRemoteAny("UpdateAutoFishingState"),     -- RF/UpdateAutoFishingState
    RequestSpin               = findRemoteAny("RequestSpin"),                -- RF/RequestSpin
    ClaimDaily                = findRemoteAny("ClaimDailyLogin"),            -- RF/ClaimDailyLogin
    -- Inventory / Listing remotes (best-effort guesses)
    GetInventory              = findRemoteAny("GetInventory") or findRemoteAny("RequestInventory") or findRemoteAny("RequestPlayerInventory"),
}

dbg("Remotes detection result:")
for k,v in pairs(REMOTES) do dbg(" ", k, tostring(v~=nil)) end

-- ========== SETTINGS (user changeable) ==========
local settings = {
    autoFish = false,
    catchMode = "Perfect", -- Perfect / Amazing / Good / Fast
    smartTiming = true,
    autoSellWhenFull = true,
    sellThreshold = 5000, -- inventory count threshold
    protectRarities = { secret=true, mythic=true, legendary=true }, -- do not sell
    autoReturnAfterSell = true,
    antiAFK = true,
    safeMode = false, -- slow down timings if true
    heartbeatTimeout = 12, -- seconds
    rareAlertEnabled = true,
}

-- mapping catch mode to timing offsets (seconds) used before firing FishingCompleted
local CATCH_TIMINGS = {
    Perfect = 0.85,
    Amazing = 0.6,
    Good = 0.35,
    Fast = 0.15,
}

-- ========== STATE ==========
local state = {
    running = false,
    lastActivity = tick(),
    fishingThread = nil,
    heartbeatThread = nil,
    savedFishingSpot = nil,
    lastSellSummary = nil,
    minigameActive = false,
    lastMinigameTs = 0,
}

local function updateActivity()
    state.lastActivity = tick()
end

-- ========== UTILITY: Inventory fetch (best-effort) ==========
local function getInventory()
    -- Try known remote if available; return table or nil
    local invRemote = REMOTES.GetInventory
    if invRemote then
        local ok, res = safeInvoke(invRemote)
        if ok and type(res) == "table" then
            dbg("Inventory retrieved via remote")
            return res
        else
            dbg("Inventory remote call failed or returned non-table")
        end
    end
    -- Fallback: cannot access inventory
    return nil
end

-- helper to count inventory count total (best-effort)
local function getInventoryCount()
    local inv = getInventory()
    if not inv then return nil end
    local count = 0
    for _, item in ipairs(inv) do
        if type(item) == "table" then
            count = count + (item.count or 1)
        else
            count = count + 1
        end
    end
    return count
end

-- helper to check if inventory contains protected rarity (best-effort)
local function inventoryHasProtected()
    local inv = getInventory()
    if not inv then return nil end
    for _, item in ipairs(inv) do
        local rarity = (item.rarity or ""):lower()
        if settings.protectRarities[rarity] then
            return true, item
        end
    end
    return false
end

-- ========== RARE ALERT HANDLER ==========
local function isRareByNameOrRarity(item)
    -- item may be table from inventory or string name; we implement best-effort detection
    if not item then return false end
    if type(item) == "table" then
        local r = tostring(item.rarity or ""):lower()
        if settings.protectRarities[r] then return true end
        local name = tostring(item.name or ""):lower()
        if name:find("secret") or name:find("mythic") or name:find("legend") then return true end
    elseif type(item) == "string" then
        local n = item:lower()
        if n:find("secret") or n:find("mythic") or n:find("legendary") then return true end
    end
    return false
end

local function rareAlert(item)
    if not settings.rareAlertEnabled then return end
    pcall(function()
        dbg("🔥 Rare catch detected:", item and (type(item)=="table" and (item.name or "item") or tostring(item)))
        -- small UI / sound: try to DisplaySystemMessage remote if available
        local dsp = findRemoteAny("DisplaySystemMessage")
        if dsp then
            pcall(function() dsp:FireServer("Rare catch detected! Check inventory", {duration=5}) end)
        end
    end)
end

-- ========== FISHING CORE ==========
local function attemptCastAndCatchCycle()
    updateActivity()
    -- equip tool
    if REMOTES.EquipToolFromHotbar then
        pcall(function()
            safeFire(REMOTES.EquipToolFromHotbar, 1)
            dbg("EquipToolFromHotbar fired")
        end)
    end

    -- small wait
    if settings.safeMode then wait(1.0) else wait(0.45) end

    -- Charge / cast
    if REMOTES.ChargeFishingRod then
        local ok, res = safeInvoke(REMOTES.ChargeFishingRod, Workspace:GetServerTimeNow())
        dbg("ChargeFishingRod ->", ok, res)
    else
        warnDbg("ChargeFishingRod remote not found")
    end

    -- short wait
    if settings.smartTiming and state.minigameActive then
        -- if minigame event detected, try to align to it:
        local offset = CATCH_TIMINGS[settings.catchMode] or 0.6
        local elapsed = tick() - state.lastMinigameTs
        -- if we are in minigame and it's recent, wait a bit to match timing
        if elapsed < 5 then
            local waitFor = math.max(0.05, offset - (elapsed*0.2))
            dbg("Smart timing active: waiting", waitFor)
            wait(waitFor)
        else
            wait(offset)
        end
    else
        wait(CATCH_TIMINGS[settings.catchMode] or 0.6)
    end

    -- optionally request minigame start
    if REMOTES.RequestFishingMinigameStarted then
        pcall(function()
            safeInvoke(REMOTES.RequestFishingMinigameStarted, -1.2379, 1)
            dbg("RequestFishingMinigameStarted invoked (best-effort)")
        end)
    end

    -- final wait then finish
    local finalDelay = CATCH_TIMINGS[settings.catchMode] or 0.6
    if settings.safeMode then finalDelay = finalDelay + 0.5 end
    wait(finalDelay)

    -- finalize catch
    if REMOTES.FishingCompleted then
        local ok, res = safeFire(REMOTES.FishingCompleted)
        dbg("FishingCompleted fired ->", ok)
        -- if server returns info about caught fish (rare), capture that (best-effort)
        if ok and res then
            if isRareByNameOrRarity(res) then
                rareAlert(res)
            end
        end
    else
        warnDbg("FishingCompleted remote not found")
    end
    updateActivity()
end

-- fishing control thread
local function startAutoFishing()
    if state.fishingThread then return end
    state.running = true
    state.fishingThread = spawn(function()
        dbg("AutoFishing thread started")
        while state.running and settings.autoFish do
            pcall(function()
                attemptCastAndCatchCycle()
            end)
            -- between cycles
            if settings.safeMode then wait(2.5) else wait(1.8) end
        end
        dbg("AutoFishing thread ended")
        state.fishingThread = nil
    end)
end

local function stopAutoFishing()
    state.running = false
    settings.autoFish = false
    dbg("Stop requested for AutoFishing")
end

-- ========== AUTO SELL LOGIC (with filter) ==========
local function doSellAllBestEffort()
    -- Try to avoid selling protected rarities:
    local inv = getInventory()
    if inv then
        -- build list of sellable items, skipping protected rarities
        local sellCandidates = {}
        for _, item in ipairs(inv) do
            local r = (item.rarity or ""):lower()
            if not settings.protectRarities[r] then
                table.insert(sellCandidates, item)
            end
        end
        if #sellCandidates == 0 then
            dbg("No sellable items found (all protected)")
            return false, "no sellable items"
        end
        -- If SellItem remote supports selling per item, attempt per-item sell
        if REMOTES.SellItem then
            local soldCount, earned = 0, 0
            for _, it in ipairs(sellCandidates) do
                local ok, res = safeInvoke(REMOTES.SellItem, it.id or it.name or it)
                if ok then
                    soldCount = soldCount + (it.count or 1)
                    earned = earned + (res and (res.amount or 0) or 0)
                end
                wait(0.15)
            end
            state.lastSellSummary = {count = soldCount, earned = earned}
            dbg("Sold per-item:", soldCount, earned)
            return true, state.lastSellSummary
        end
        -- fallback: call SellAllItems but it may sell protected items => avoid
        if REMOTES.SellAllItems then
            warnDbg("SellAllItems exists but inventory listing available — using per-item sell to respect filters")
            local ok,res = safeInvoke(REMOTES.SellAllItems)
            state.lastSellSummary = {raw = res}
            return ok, res
        end
        return false, "no suitable sell remote"
    else
        -- no inventory remote available. Fallback behavior:
        if REMOTES.SellAllItems then
            -- We cannot filter; to protect rarities, we will refuse auto-sell unless user forces it
            warnDbg("No inventory info available. Auto-sell disabled to prevent accidental selling of protected rarities.")
            return false, "no-inventory"
        elseif REMOTES.SellItem then
            -- can't know list; user must use manual Sell Now and select items
            warnDbg("SellItem exists but no inventory info; manual sell required")
            return false, "manual-required"
        end
        return false, "no-sell-remote"
    end
end

-- helper to auto-sell when threshold reached
local function autoSellWatcher()
    spawn(function()
        while true do
            if settings.autoSellWhenFull then
                local count = getInventoryCount()
                if count and count >= settings.sellThreshold then
                    dbg("Inventory threshold reached:", count, "attempting to sell")
                    local ok, res = doSellAllBestEffort()
                    if ok then
                        dbg("Auto-sell result:", res)
                        if settings.autoReturnAfterSell and state.savedFishingSpot then
                            -- teleport back to saved spot
                            local char = workspace:FindFirstChild("Characters") and workspace.Characters:FindFirstChild(LocalPlayer.Name)
                            if char and char:FindFirstChild("HumanoidRootPart") then
                                char.HumanoidRootPart.CFrame = state.savedFishingSpot
                                dbg("Returned to saved fishing spot after sell")
                            end
                        end
                    else
                        dbg("Auto-sell skipped:", res)
                    end
                end
            end
            wait(5)
        end
    end)
end

-- ========== TELEPORTS (NPC & ISLAND list provided) ==========
local TELEPORTS = {
    NPCs = {
        ["Rods Here"] = nil,
        ["Bobbers"] = nil,
        ["Skin Crates"] = nil,
        ["Sell Here!"] = nil,
        ["Utility Store"] = nil,
        ["Spin Wheel"] = nil,
        ["Traveling Merchant"] = nil,
    },
    Islands = {
        ["Crater Island"] = nil,
        ["Tropical Grove"] = nil,
        ["Coral Reefs"] = nil,
        ["Weather Machine"] = nil,
        ["Lost Isle"] = nil,
        ["Kohana"] = nil,
        ["Kohana Volcano"] = nil,
        ["Esoteric Depths"] = nil,
    }
}

-- Heuristic: attempt to find parts/models by name in workspace and populate TELEPORTS with CFrame
local function scanAndPopulateTeleports()
    for key,_ in pairs(TELEPORTS.NPCs) do TELEPORTS.NPCs[key] = nil end
    for key,_ in pairs(TELEPORTS.Islands) do TELEPORTS.Islands[key] = nil end

    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") or obj:IsA("Model") then
            local name = tostring(obj.Name):lower()
            for key,_ in pairs(TELEPORTS.NPCs) do
                if name:find(key:lower():gsub("%s","")) or name:find(key:lower():sub(1,6)) then
                    local pos = (obj:IsA("BasePart") and obj.Position) or (obj:IsA("Model") and (obj:FindFirstChild("PrimaryPart") and obj.PrimaryPart.Position or (obj:FindFirstChildWhichIsA("BasePart") and obj:FindFirstChildWhichIsA("BasePart").Position)))
                    if pos then TELEPORTS.NPCs[key] = pos end
                end
            end
            for key,_ in pairs(TELEPORTS.Islands) do
                if name:find(key:lower():gsub("%s","")) or name:find(key:lower():sub(1,6)) then
                    local pos = (obj:IsA("BasePart") and obj.Position) or (obj:IsA("Model") and (obj:FindFirstChild("PrimaryPart") and obj.PrimaryPart.Position or (obj:FindFirstChildWhichIsA("BasePart") and obj:FindFirstChildWhichIsA("BasePart").Position)))
                    if pos then TELEPORTS.Islands[key] = pos end
                end
            end
        end
    end
    dbg("Teleport scan finished")
end

-- manual teleport function
local function teleportToPos(pos)
    local char = workspace:FindFirstChild("Characters") and workspace.Characters:FindFirstChild(LocalPlayer.Name)
    if not char then warnDbg("Character not found for teleport") return false end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then warnDbg("HRP not found") return false end
    hrp.CFrame = CFrame.new(pos + Vector3.new(0,3,0))
    updateActivity()
    return true
end

-- ========== ANTI AFK & RECONNECT ==========
-- Anti-AFK: use VirtualUser pattern
local function setupAntiAFK()
    pcall(function()
        LocalPlayer.Idled:Connect(function()
            local ok2, vu = pcall(function() return game:GetService("VirtualUser") end)
            if ok2 and vu then
                vu:CaptureController()
                vu:ClickButton2(Vector2.new(0,0))
                dbg("Anti-AFK: VirtualUser click performed")
            else
                -- fallback: small camera rotate
                pcall(function()
                    local cam = workspace.CurrentCamera
                    if cam then
                        cam.CFrame = cam.CFrame * CFrame.Angles(0,0.01,0)
                        dbg("Anti-AFK: camera nudge")
                    end
                end)
            end
        end)
    end)
end

-- Auto Reconnect / Retry: try to re-init if key remotes become nil or heavy errors occur
local function attemptReconnect()
    dbg("Attempting reconnect: rescanning net & remotes")
    net = findNet() or net
    rf = net:FindFirstChild("RF") or net
    re = net:FindFirstChild("RE") or net
    -- refresh remotes table (best-effort)
    REMOTES.ChargeFishingRod = findRemoteAny("ChargeFishingRod")
    REMOTES.FishingCompleted = findRemoteAny("FishingCompleted")
    REMOTES.EquipToolFromHotbar = findRemoteAny("EquipToolFromHotbar")
    REMOTES.SellAllItems = findRemoteAny("SellAllItems")
    REMOTES.SellItem = findRemoteAny("SellItem")
    REMOTES.GetInventory = findRemoteAny("GetInventory") or findRemoteAny("RequestInventory")
    dbg("Reconnect finished, remotes updated")
end

-- Heartbeat watchdog: restart fishing thread if not active
local function startHeartbeat()
    if state.heartbeatThread then return end
    state.heartbeatThread = spawn(function()
        while true do
            local last = state.lastActivity or tick()
            if tick() - last > settings.heartbeatTimeout then
                warnDbg("Heartbeat timeout detected. Attempting to restart fishing thread.")
                -- restart
                pcall(function()
                    state.running = false
                    wait(0.5)
                    attemptReconnect()
                    if settings.autoFish then
                        state.running = true
                        startAutoFishing()
                        dbg("Heartbeat: restarted auto-fish")
                    end
                end)
                updateActivity()
            end
            wait(math.max(1, settings.heartbeatTimeout/2))
        end
    end)
end

-- ========== GUI (ProjectMadara) ==========
local Main = ProjectMadara:Window({ Title = "FishItHub v3.5 Ultimate" })

-- Tabs
local T_fish = Main:Tab({ Name = "Fishing", tabColor = Color3.fromHex("#3CB371"), Image = "rbxassetid://10709769841" })
local T_sell = Main:Tab({ Name = "Sell", tabColor = Color3.fromHex("#FFD700"), Image = "rbxassetid://10734952479" })
local T_travel = Main:Tab({ Name = "Travel", tabColor = Color3.fromHex("#1E90FF"), Image = "rbxassetid://10734886202" })
local T_settings = Main:Tab({ Name = "Settings", tabColor = Color3.fromHex("#FFA500"), Image = "rbxassetid://10734886202" })
local T_debug = Main:Tab({ Name = "Debug", tabColor = Color3.fromHex("#BA55D3"), Image = "rbxassetid://10747347376" })

-- Fishing tab
T_fish:Label("🎣 Core Fishing")
T_fish:Toggle({ Name = "Auto Cast & Catch", Default = false, Callback = function(v)
    settings.autoFish = v
    dbg("AutoFish set ->", v)
    if v then startAutoFishing() end
end})

T_fish:Dropdown({ Name = "Catch Accuracy Mode", Default = "Perfect", Options = {"Perfect","Amazing","Good","Fast"}, Callback = function(opt)
    settings.catchMode = opt
    dbg("Catch mode set to", opt)
end})

T_fish:Toggle({ Name = "Smart Cast Timing (use minigame event)", Default = true, Callback = function(v) settings.smartTiming = v; dbg("SmartTiming:", v) end })
T_fish:Toggle({ Name = "Safe Mode (slow)", Default = false, Callback = function(v) settings.safeMode = v; dbg("SafeMode:", v) end })
T_fish:Button({ Name = "Stop AutoFishing", Callback = function() stopAutoFishing() end })
T_fish:Label("Fishing Spot")
T_fish:Button({ Name = "Save Current Spot", Callback = function()
    local char = workspace:FindFirstChild("Characters") and workspace.Characters:FindFirstChild(LocalPlayer.Name)
    if not char then return warnDbg("Character not found") end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return warnDbg("HRP not found") end
    state.savedFishingSpot = hrp.CFrame
    dbg("Saved current fishing spot")
end})
T_fish:Button({ Name = "Teleport to Saved Spot", Callback = function()
    if not state.savedFishingSpot then return warnDbg("No saved fishing spot") end
    local char = workspace:FindFirstChild("Characters") and workspace.Characters:FindFirstChild(LocalPlayer.Name)
    if not char then return warnDbg("Character not found") end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return warnDbg("HRP not found") end
    hrp.CFrame = state.savedFishingSpot
    dbg("Teleported to saved fishing spot")
end})

-- Sell tab
T_sell:Label("💰 Sell Controls")
T_sell:Toggle({ Name = "Auto Sell When Full (threshold 5000)", Default = true, Callback = function(v) settings.autoSellWhenFull = v; dbg("AutoSellWhenFull:", v) end })
T_sell:Button({ Name = "Manual Sell Now (best-effort)", Callback = function()
    dbg("Manual sell requested")
    local ok,res = doSellAllBestEffort()
    dbg("Manual sell result ->", ok, res)
end})
T_sell:Toggle({ Name = "Return to Spot After Sell", Default = true, Callback = function(v) settings.autoReturnAfterSell = v; dbg("ReturnAfterSell:", v) end })
T_sell:Label("Protect rarities from selling (auto):")
T_sell:Toggle({ Name = "Protect Secret/Mythic/Legendary", Default = true, Callback = function(v)
    if v then
        settings.protectRarities.secret = true; settings.protectRarities.mythic = true; settings.protectRarities.legendary = true
    else
        settings.protectRarities.secret = false; settings.protectRarities.mythic = false; settings.protectRarities.legendary = false
    end
    dbg("Protect rarities ->", v)
end})

-- Travel tab: populate teleport scan on open
T_travel:Label("📍 Teleport")
T_travel:Button({ Name = "Scan World for NPCs & Islands (heuristic)", Callback = function()
    scanAndPopulateTeleports()
    dbg("Teleport targets:")
    for k,v in pairs(TELEPORTS.NPCs) do dbg(" NPC:", k, v and tostring(v)) end
    for k,v in pairs(TELEPORTS.Islands) do dbg(" Island:", k, v and tostring(v)) end
end})

-- create teleport buttons from provided lists
for name,_ in pairs(TELEPORTS.NPCs) do
    local n = name
    T_travel:Button({ Name = "Teleport NPC: "..n, Callback = function()
        if not TELEPORTS.NPCs[n] then warnDbg("No target found for", n); return end
        teleportToPos(TELEPORTS.NPCs[n])
        dbg("Teleported to NPC:", n)
    end})
end
for name,_ in pairs(TELEPORTS.Islands) do
    local n = name
    T_travel:Button({ Name = "Teleport Island: "..n, Callback = function()
        if not TELEPORTS.Islands[n] then warnDbg("No target found for", n); return end
        teleportToPos(TELEPORTS.Islands[n])
        dbg("Teleported to Island:", n)
    end})
end

-- Settings tab
T_settings:Label("⚙️ Settings & Protection")
T_settings:Toggle({ Name = "Anti-AFK", Default = true, Callback = function(v) settings.antiAFK = v; if v then setupAntiAFK() end; dbg("AntiAFK:", v) end })
T_settings:Toggle({ Name = "Safe Mode (throttle actions)", Default = false, Callback = function(v) settings.safeMode = v; dbg("SafeMode:", v) end })
T_settings:Slider({ Name = "Heartbeat Timeout (s)", Min = 6, Max = 30, Default = settings.heartbeatTimeout, Callback = function(v) settings.heartbeatTimeout = v; dbg("HeartbeatTimeout:", v) end})
T_settings:Button({ Name = "Force Reconnect / Rescan Remotes", Callback = function() attemptReconnect(); dbg("Manual reconnect attempted") end})

-- Debug tab
T_debug:Label("🧾 Debug Console")
T_debug:Button({ Name = "Copy Remote List to Clipboard", Callback = function()
    local lines = {}
    for _,v in ipairs(net:GetDescendants()) do
        if v:IsA("RemoteEvent") or v:IsA("RemoteFunction") then
            table.insert(lines, tostring(v.ClassName).." : "..v:GetFullName())
        end
    end
    local txt = table.concat(lines, "\n")
    if setclipboard then setclipboard(txt); dbg("Remote list copied to clipboard") else dbg("setclipboard not supported") end
end})
T_debug:Button({ Name = "Show Last Sell Summary", Callback = function()
    dbg("Last sell summary:", state.lastSellSummary and tostring(state.lastSellSummary.count) or "none", state.lastSellSummary)
end})
T_debug:Button({ Name = "Start Heartbeat Watchdog", Callback = function() startHeartbeat(); dbg("Heartbeat started") end })

-- start services
if settings.antiAFK then setupAntiAFK() end
autoSellWatcher()
startHeartbeat()

dbg("FishItHub v3.5 loaded. Use GUI to control features. Check console for detailed logs.")

-- END OF SCRIPT
