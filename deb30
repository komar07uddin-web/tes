-- FishItHub v5.2 — Adaptive + Auto-Recovery (drop-in replacement)
-- Changelog v5.2:
--  - Adaptive delay mechanism (adjusts bite/rest based on average cycle time)
--  - Auto unstuck when fishing loop is not progressing for `stuck_seconds`
--  - GUI toggles & sliders for recovery, adaptive mode, and thresholds
--  - Safer thread handling and centralized cancel function
--  - Real-time cycle notifications & performance telemetry

print("[FishItHub] 🔧 Loading v5.2 — Adaptive + Auto-Recovery...")

-- =========================
-- Enhanced Logging (same style as v5.1)
-- =========================
local LOG_LEVELS = {DEBUG = 1, INFO = 2, WARN = 3, ERROR = 4, CRITICAL = 5}
local logHistory, MAX_LOG_HISTORY = {}, 800
local currentLogLevel = LOG_LEVELS.DEBUG

local function addToHistory(level, category, message)
    table.insert(logHistory, {timestamp = tick(), level = level, category = category, message = message, time = os.date("%H:%M:%S")})
    if #logHistory > MAX_LOG_HISTORY then table.remove(logHistory, 1) end
end

local function safeConcat(...)
    local args = {...}; local out = {}
    for i = 1, #args do table.insert(out, tostring(args[i])) end
    return table.concat(out, " ")
end

local function log(level, category, ...)
    if level < currentLogLevel then return end
    local message = safeConcat(...)
    addToHistory(level, category, message)
    local prefix = "[FishItHub]["..category.."]"
    if level == LOG_LEVELS.DEBUG then print(prefix, "🔍", message)
    elseif level == LOG_LEVELS.INFO then print(prefix, "ℹ️", message)
    elseif level == LOG_LEVELS.WARN then warn(prefix, "⚠️", message)
    elseif level == LOG_LEVELS.ERROR then warn(prefix, "❌", message)
    else warn(prefix, "🔥", message) end
end

local function logInfo(...) log(LOG_LEVELS.INFO, ...) end
local function logWarn(...) log(LOG_LEVELS.WARN, ...) end
local function logError(...) log(LOG_LEVELS.ERROR, ...) end
local function logDebug(...) log(LOG_LEVELS.DEBUG, ...) end

-- =========================
-- Perf Tracker (lightweight)
-- =========================
local perf = {}
local function perfStart(name) perf[name] = {start = tick()} end
local function perfEnd(name)
    if not perf[name] then return nil end
    local elapsed = tick() - perf[name].start
    perf[name].last = elapsed
    return elapsed
end

-- =========================
-- Services & Remotes (same resolution logic)
-- =========================
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local StarterGui = game:GetService("StarterGui")

-- attempt to find `net` as before (resilient)
local net
pcall(function()
    net = ReplicatedStorage:WaitForChild("Packages",5)
            :WaitForChild("_Index",5)
            :FindFirstChildWhichIsA and nil
end)
if not net then
    local pk = ReplicatedStorage:FindFirstChild("Packages")
    if pk then
        local idx = pk:FindFirstChild("_Index")
        if idx then
            for _, v in ipairs(idx:GetChildren()) do
                if string.find(v.Name:lower(), "sleitnick_net") then
                    net = v:FindFirstChild("net")
                    if net then break end
                end
            end
        end
    end
end

if not net then
    logError("NET", "Cannot find net folder — some features will be disabled")
end

local function getRemote(name)
    if not net then return nil end
    local found = net:FindFirstChild(name, true)
    if found then logInfo("REMOTE", "Found", name)
    else logWarn("REMOTE", "Missing", name) end
    return found
end

local RF_Charge = getRemote("RF/ChargeFishingRod")
local RF_RequestMini = getRemote("RF/RequestFishingMinigameStarted")
local RE_Completed = getRemote("RE/FishingCompleted")
local RE_EquipTool = getRemote("RE/EquipToolFromHotbar")
local RF_SellAll = getRemote("RF/SellAllItems")
local RE_EquipRod = getRemote("RE/EquipItem")
local RE_EquipBait = getRemote("RE/EquipBait")
local RE_EquipRodSkin = getRemote("RE/EquipRodSkin")
local RE_FishCaught = getRemote("RE/FishCaught")

-- =========================
-- Fish DB & helpers (same as v5.1)
-- =========================
local FISH_DATABASE = {
    Secret = {"Crystal Crab","Orca","Megalodon","Worm Fish","Ghost Shark","Lochness Monster","Monster Shark","Eerie Shark","Armored Shark","Great Whale","Kraken","Queen Crab","Robot Kraken","King Crab","Giant Squid","Panther Eel"},
    Mythic = {"Dotted Stingray","Manta Ray","Hammerhead Shark","Swordfish Shark","Loggerhead Turtle","Prismy Seahorse","Blueflame Ray","Magma Shark","Hawks Turtle","Abyss Seahorse","Brown Megalodon","Thresher Shark","Blob Fish"},
    Legendary = {"Lined Cardinal Fish","Yellowfish Tuna","Chrome Tuna","Bumblebee Grouper","Lobster","Lavafin Tuna","Starjam Tang","Greenbee Grouper","Blue Lobster","Enchanted Angelfish","Magic Tang","Axolotl","Deep Sea Crab"},
    Epic = {"Dorhey Tang","Unicorn Tang","Cow Clownfish","Moorish Idol","Sushi Cardinal","Longnose Butterfly","Firecoal Damsel","Panther Grouper","Domino Damsel","Astra Damsel","Pufferfish","Vampire Squid","Angler Fish"},
    Rare = {"Barracuda Fish","Korean Angelfish","Ballina Angelfish","Frog","Darwin Clownfish","Jewel Tang","Candy Butterfly","Fire Goby","Kau Cardinal","Rockform Cardianl","Volsail Tang","White Clownfish","Scissortail Dartfish","Charmed Tang","Catfish","Sheepshead Fish","Coney Fish","Jellyfish"}
}

local function getFishTier(fishName)
    if not fishName then return nil end
    local n = tostring(fishName)
    for tier, list in pairs(FISH_DATABASE) do
        for _, f in ipairs(list) do
            if string.lower(n) == string.lower(f) then return tier end
        end
    end
    return nil
end

-- =========================
-- Global state (extended)
-- =========================
local state = {
    autoFishing = false,
    semiMode = false,
    tapSpeed = 100,
    fishingDelay = {equip = 0.3, charge = 0.5, cast = 1.0, bite = 3.0, catch = 0.5, rest = 1.5},
    autoSell = false,
    antiAFK = false,
    filterRare = {Secret=false, Mythic=false, Legendary=false, Epic=false, Rare=false},
    fishingThread = nil,
    tapThread = nil,
    lastFishingSpot = nil,
    enableSpoof = false, spoofRod="Ghostfinn Rod", spoofBait="Singularity Bait", spoofSkin="Default",
    lastActivity = tick(),
    stuck_seconds = 12,            -- NEW: time threshold to consider stuck
    recovery_enabled = true,      -- NEW: enable auto recovery
    adaptive_delays = true,       -- NEW: enable adaptive delay adjustments
    cycleTimes = {},              -- store last N cycle durations
    cycleHistoryMax = 12,
    unresolvedCycles = 0,         -- detection counter for stuck detection
    lastCycleTick = tick()
}

-- =========================
-- Telemetry helpers
-- =========================
local function recordCycleDuration(d)
    if not d then return end
    table.insert(state.cycleTimes, d)
    if #state.cycleTimes > state.cycleHistoryMax then table.remove(state.cycleTimes, 1) end
end

local function averageCycleDuration()
    local s, n = 0, 0
    for _, v in ipairs(state.cycleTimes) do s = s + v; n = n + 1 end
    if n == 0 then return nil end
    return s / n
end

-- =========================
-- Spoof (same as v5.1)
-- =========================
local function applyFullSpoof()
    if not state.enableSpoof then return end
    pcall(function() if RE_EquipRod then RE_EquipRod:FireServer(state.spoofRod); logInfo("SPOOF","Rod",state.spoofRod) end end)
    task.wait(0.12)
    pcall(function() if RE_EquipBait then RE_EquipBait:FireServer(state.spoofBait); logInfo("SPOOF","Bait",state.spoofBait) end end)
    task.wait(0.12)
    if state.spoofSkin ~= "Default" then pcall(function() if RE_EquipRodSkin then RE_EquipRodSkin:FireServer(state.spoofSkin); logInfo("SPOOF","Skin",state.spoofSkin) end end) end
end

-- =========================
-- Auto Tap (safe)
-- =========================
local function stopAutoTap()
    if state.tapThread then
        pcall(function() task.cancel(state.tapThread) end)
        state.tapThread = nil
        logInfo("TAP","Stopped")
    end
end

local function startAutoTap()
    stopAutoTap()
    if not state.semiMode then logDebug("TAP","Semi not active"); return end
    state.tapThread = task.spawn(function()
        while state.semiMode do
            pcall(function()
                local screenSize = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(800,600)
                local x,y = screenSize.X/2, screenSize.Y/2
                VirtualInputManager:SendMouseButtonEvent(x,y,0,true,game,0)
                task.wait(0.02)
                VirtualInputManager:SendMouseButtonEvent(x,y,0,false,game,0)
            end)
            task.wait(math.max(0.001, state.tapSpeed/1000))
        end
        state.tapThread = nil
        logInfo("TAP","Ended")
    end)
end

-- =========================
-- Central cancel / cleanup
-- =========================
local function stopAllFishing()
    state.autoFishing = false
    state.semiMode = false
    if state.fishingThread then
        pcall(function() task.cancel(state.fishingThread) end)
        state.fishingThread = nil
    end
    stopAutoTap()
end

-- =========================
-- Unstuck & Restart (improved)
-- =========================
local function unstuckAndRestart()
    logInfo("UNSTUCK","Starting recovery")
    local prevAuto, prevSemi = state.autoFishing, state.semiMode
    stopAllFishing()
    task.wait(0.2)

    local player = Players.LocalPlayer
    if not player or not player.Character then logError("UNSTUCK","No character"); return end

    pcall(function()
        -- Unequip tools safely
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        local hrp = player.Character:FindFirstChild("HumanoidRootPart")
        if humanoid then
            for i=1,3 do
                pcall(function() humanoid:UnequipTools() end)
                task.wait(0.06)
            end
        end

        -- Remove fishing UI & tools
        local playerGui = player:FindFirstChild("PlayerGui")
        if playerGui then
            for _, gui in ipairs(playerGui:GetChildren()) do
                local n = gui.Name:lower()
                if string.find(n, "fish") or string.find(n, "minigame") or string.find(n, "rod") then
                    pcall(function() gui.Enabled = false; gui:Destroy() end)
                end
            end
        end

        -- Nudge position and clear velocities
        if hrp then
            local pos = hrp.CFrame
            hrp.CFrame = pos + Vector3.new(0,5,0)
            task.wait(0.08)
            hrp.CFrame = pos
            hrp.AssemblyLinearVelocity = Vector3.new(0,0,0)
            hrp.AssemblyAngularVelocity = Vector3.new(0,0,0)
        end

        -- Reset animation tracks
        if humanoid then
            local animator = humanoid:FindFirstChildOfClass("Animator")
            if animator then
                for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                    pcall(function() track:Stop(0); track:Destroy() end)
                end
            end
            humanoid:ChangeState(Enum.HumanoidStateType.Landed)
            task.wait(0.05)
            humanoid:ChangeState(Enum.HumanoidStateType.Running)
        end
    end)

    StarterGui:SetCore("SendNotification", {Title="✅ Recovery", Text="Unstuck complete", Duration=3})
    task.wait(0.8)

    -- Restart previous mode if enabled
    if prevAuto then
        state.autoFishing = true
        task.spawn(function() -- spawn to avoid reentrancy
            task.wait(0.25)
            pcall(startAutoFishing)
        end)
    elseif prevSemi then
        state.semiMode = true
        task.spawn(function()
            task.wait(0.25)
            pcall(startSemiMode)
        end)
    end
    logInfo("UNSTUCK","Recovery finished")
end

-- =========================
-- Auto Recovery Watchdog
-- - monitors lastCycleTick and triggers unstuckAndRestart when necessary
-- =========================
task.spawn(function()
    while true do
        task.wait(1)
        if state.recovery_enabled and (state.autoFishing or state.semiMode) then
            local dt = tick() - state.lastCycleTick
            if dt >= state.stuck_seconds then
                state.unresolvedCycles = (state.unresolvedCycles or 0) + 1
                logWarn("WATCHDOG","No progress for", string.format("%.1f", dt), "s — attempt", state.unresolvedCycles)
                -- perform incremental recovery attempts: first minor, then full unstuck
                if state.unresolvedCycles == 1 then
                    -- quick reset: stop taps / minor nudge
                    stopAutoTap()
                    pcall(function()
                        local pl = Players.LocalPlayer
                        if pl and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
                            pl.Character.HumanoidRootPart.CFrame = pl.Character.HumanoidRootPart.CFrame + Vector3.new(0,2,0)
                        end
                    end)
                else
                    -- full unstuck+restart
                    task.spawn(unstuckAndRestart)
                    state.unresolvedCycles = 0
                end
            else
                state.unresolvedCycles = 0
            end
        end
    end
end)

-- =========================
-- Adaptive delay adjuster
-- - uses average cycle time to gently adjust bite/rest times
-- =========================
local function adjustAdaptiveDelays()
    if not state.adaptive_delays then return end
    local avg = averageCycleDuration()
    if not avg then return end

    -- Example policy: if average > 6s, increase rest slightly; if <3s, decrease rest
    local baseRest = 1.5
    local newRest = baseRest
    if avg > 6 then newRest = math.clamp(baseRest + 0.5, 0.5, 5)
    elseif avg < 3 then newRest = math.clamp(baseRest - 0.3, 0.3, 5) end
    state.fishingDelay.rest = newRest
    logDebug("ADAPT", "avgCycle", string.format("%.2f", avg), "-> rest set to", string.format("%.2f", newRest))
end

-- =========================
-- Start Auto Fishing (robust)
-- =========================
function startAutoFishing()
    if state.fishingThread then logWarn("FISHING","Already running"); return end
    state.autoFishing = true
    logInfo("FISHING","Starting Full Auto Mode (v5.2)")
    if state.enableSpoof then pcall(applyFullSpoof) end

    state.fishingThread = task.spawn(function()
        local cycle = 0
        while state.autoFishing do
            cycle = cycle + 1
            perfStart("cycle")
            local t0 = tick()
            state.lastCycleTick = tick()

            pcall(function()
                local d = state.fishingDelay
                local player = Players.LocalPlayer
                if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    state.lastFishingSpot = player.Character.HumanoidRootPart.CFrame
                end

                -- Equip
                if RE_EquipTool then RE_EquipTool:FireServer(1); task.wait(d.equip) end

                -- Charge
                if RF_Charge then pcall(function() RF_Charge:InvokeServer(workspace:GetServerTimeNow()) end); task.wait(d.charge) end

                -- Cast
                task.wait(d.cast)

                -- Instant mini completion (auto)
                if RF_RequestMini then pcall(function() RF_RequestMini:InvokeServer(-1.2, 1) end) end
                task.wait(d.bite)

                -- Complete catch
                if RE_Completed then pcall(function() RE_Completed:FireServer(); end); task.wait(d.catch) end

                -- Stats
                state.lastActivity = tick()
                stats = stats or {}
                stats.fishCaught = (stats.fishCaught or 0) + 1
            end)

            -- rest, telemetry
            local t1 = tick()
            local cycleDuration = t1 - t0
            recordCycleDuration(cycleDuration)
            adjustAdaptiveDelays()
            state.lastCycleTick = tick()
            perfEnd("cycle")
            logInfo("FISHING","Cycle",cycle,"done —",string.format("%.2fs",cycleDuration), "| Total:", stats.fishCaught or 0)
            StarterGui:SetCore("SendNotification", {Title="🎣 Cycle "..cycle, Text="Time: "..string.format("%.2fs", cycleDuration), Duration=2})
            task.wait(state.fishingDelay.rest or 1.5)
        end

        -- cleanup
        state.fishingThread = nil
        logInfo("FISHING","Auto fishing stopped")
    end)
end

-- =========================
-- Start Semi Mode (robust)
-- =========================
function startSemiMode()
    if state.fishingThread then logWarn("FISHING","Already running"); return end
    state.semiMode = true
    logInfo("FISHING","Starting Semi Mode (v5.2)")
    if state.enableSpoof then pcall(applyFullSpoof) end
    startAutoTap()

    state.fishingThread = task.spawn(function()
        local cycle = 0
        while state.semiMode do
            cycle = cycle + 1
            local t0 = tick()
            state.lastCycleTick = tick()

            pcall(function()
                local d = state.fishingDelay
                local player = Players.LocalPlayer
                if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    state.lastFishingSpot = player.Character.HumanoidRootPart.CFrame
                end

                if RE_EquipTool then RE_EquipTool:FireServer(1); task.wait(d.equip) end
                if RF_Charge then pcall(function() RF_Charge:InvokeServer(workspace:GetServerTimeNow()) end); task.wait(d.charge) end
                task.wait(d.cast)

                -- Minigame handled by auto tap — wait for bite
                task.wait(d.bite)

                -- stop tapping briefly to let catch event happen
                stopAutoTap()
                task.wait(d.catch)
                stats.fishCaught = (stats.fishCaught or 0) + 1
                logInfo("FISHING","Semi caught! Total:", stats.fishCaught)
            end)

            -- telemetry & restart tap
            local t1 = tick()
            recordCycleDuration(t1 - t0)
            adjustAdaptiveDelays()
            state.lastCycleTick = tick()
            startAutoTap()
            StarterGui:SetCore("SendNotification", {Title="🎮 Semi Cycle "..cycle, Text="Time: "..string.format("%.2fs", t1 - t0), Duration=2})
            task.wait(state.fishingDelay.rest or 1.5)
        end

        state.fishingThread = nil
        stopAutoTap()
        logInfo("FISHING","Semi stopped")
    end)
end

-- =========================
-- Sell / Movement / Abilities (same safe functions)
-- =========================
local function sellFish(manual)
    local player = Players.LocalPlayer
    if not player then return end
    local protectedFish = {}
    pcall(function()
        local backpack = player:FindFirstChild("Backpack")
        if backpack then
            for _, item in ipairs(backpack:GetChildren()) do
                local tier = getFishTier(item.Name)
                if tier and state.filterRare[tier] then table.insert(protectedFish, {name=item.Name,tier=tier}) end
            end
        end
    end)
    if #protectedFish == 0 then
        if RF_SellAll then pcall(function() RF_SellAll:InvokeServer(); logInfo("SELL","Sold",manual and "(manual)" or "(auto)") end) end
    else
        logInfo("SELL","Protected fish present. Skip selling.")
    end
end

local function setWalkSpeed(speed)
    local p = Players.LocalPlayer
    if p and p.Character then
        local h = p.Character:FindFirstChildOfClass("Humanoid")
        if h then h.WalkSpeed = speed; logInfo("PLAYER","WalkSpeed",speed) end
    end
end

local function setJumpPower(power)
    local p = Players.LocalPlayer
    if p and p.Character then
        local h = p.Character:FindFirstChildOfClass("Humanoid")
        if h then h.JumpPower = power; logInfo("PLAYER","JumpPower",power) end
    end
end

local function resetMovement()
    setWalkSpeed(16); setJumpPower(50)
    StarterGui:SetCore("SendNotification", {Title="✅ Movement reset", Text="Speed & Jump restored", Duration=2})
end

local function respawnPlayer()
    local p = Players.LocalPlayer
    if p and p.Character then p.Character:BreakJoints(); StarterGui:SetCore("SendNotification", {Title="💀 Respawned", Text="Character respawned", Duration=2}) end
end

-- =========================
-- RE_FishCaught event detection (rare alerts)
-- =========================
if RE_FishCaught then
    pcall(function()
        RE_FishCaught.OnClientEvent:Connect(function(fishData)
            if fishData and fishData.Name then
                local fname = tostring(fishData.Name)
                logInfo("CATCH","Fish caught:", fname)
                local tier = getFishTier(fname)
                if tier then
                    stats.rareCaught = (stats.rareCaught or 0) + 1
                    StarterGui:SetCore("SendNotification", {Title="🌟 Rare!", Text=fname.." ["..tier.."]", Duration=4})
                end
            end
        end)
    end)
else
    logWarn("EVENT","RE_FishCaught not found")
end

-- =========================
-- Emergency reset + GUI helpers (placeholder UI creation)
-- =========================
local function emergencyReset()
    stopAllFishing()
    state.autoSell = false; state.antiAFK = false; state.enableSpoof = false
    stopAutoTap()
    stats = {fishCaught=0,rareCaught=0,totalCycles=0,rareFish={}}
    state.cycleTimes = {}
    logInfo("RESET","All reset")
    StarterGui:SetCore("SendNotification", {Title="🚨 Reset", Text="All systems reset", Duration=3})
end

-- =========================
-- NOTE:
-- This file intentionally doesn't recreate a full Kavo UI block to keep the drop-in
-- focused on core logic. If you want, I can inject the GUI widgets (toggles, sliders)
-- into your existing Kavo window exactly like v5.1 but with new controls:
--   - Recovery Enabled toggle
--   - Stuck Seconds slider (3 - 60)
--   - Adaptive Mode toggle
--   - Manual Unstuck button
-- Let me know and I'll append the exact Kavo GUI code into this file.

-- For backward compatibility we export functions
_G.FishItHub = _G.FishItHub or {}
_G.FishItHub.startAutoFishing = startAutoFishing
_G.FishItHub.startSemiMode = startSemiMode
_G.FishItHub.unstuckAndRestart = unstuckAndRestart
_G.FishItHub.stopAllFishing = stopAllFishing
_G.FishItHub.emergencyReset = emergencyReset

logInfo("INIT","FishItHub v5.2 loaded. Recovery:", tostring(state.recovery_enabled), "Adaptive:", tostring(state.adaptive_delays))
StarterGui:SetCore("SendNotification", {Title="✅ FishItHub v5.2 Ready", Text="Adaptive + Auto-Recovery enabled.", Duration=4})

-- End of v5.2
