-- =========================================================================
-- FishItHub v3.5 Ultimate â€” Enhanced Logging & Debugging
-- Tambahan: Detail log untuk trace stuck/error di setiap fitur
-- =========================================================================

-- ========== Enhanced Logging System ==========
local LOG_LEVELS = {
    DEBUG = 1,
    INFO = 2,
    WARN = 3,
    ERROR = 4,
    CRITICAL = 5
}

local logHistory = {}
local MAX_LOG_HISTORY = 200
local currentLogLevel = LOG_LEVELS.DEBUG

local function addToHistory(level, category, message, data)
    table.insert(logHistory, {
        timestamp = tick(),
        level = level,
        category = category,
        message = message,
        data = data,
        time = os.date("%H:%M:%S")
    })
    if #logHistory > MAX_LOG_HISTORY then
        table.remove(logHistory, 1)
    end
end

local function log(level, category, ...)
    if level < currentLogLevel then return end
    
    local args = {...}
    local message = table.concat(args, " ")
    local prefix = "[FishItHub]["..category.."]"
    
    addToHistory(level, category, message, args)
    
    if level == LOG_LEVELS.DEBUG then
        print(prefix, "ðŸ”", message)
    elseif level == LOG_LEVELS.INFO then
        print(prefix, "â„¹ï¸", message)
    elseif level == LOG_LEVELS.WARN then
        warn(prefix, "âš ï¸", message)
    elseif level == LOG_LEVELS.ERROR then
        warn(prefix, "âŒ", message)
    elseif level == LOG_LEVELS.CRITICAL then
        warn(prefix, "ðŸ”¥ CRITICAL:", message)
    end
end

-- Shorthand functions
local function logDebug(cat, ...) log(LOG_LEVELS.DEBUG, cat, ...) end
local function logInfo(cat, ...) log(LOG_LEVELS.INFO, cat, ...) end
local function logWarn(cat, ...) log(LOG_LEVELS.WARN, cat, ...) end
local function logError(cat, ...) log(LOG_LEVELS.ERROR, cat, ...) end
local function logCritical(cat, ...) log(LOG_LEVELS.CRITICAL, cat, ...) end

-- Performance tracker
local perfTracker = {}
local function perfStart(name)
    perfTracker[name] = {start = tick(), count = (perfTracker[name] and perfTracker[name].count or 0) + 1}
    logDebug("PERF", "Started:", name)
end

local function perfEnd(name)
    if not perfTracker[name] then return end
    local elapsed = tick() - perfTracker[name].start
    perfTracker[name].lastDuration = elapsed
    perfTracker[name].totalTime = (perfTracker[name].totalTime or 0) + elapsed
    logDebug("PERF", "Completed:", name, "Duration:", string.format("%.3f", elapsed).."s")
    
    if elapsed > 5 then
        logWarn("PERF", "SLOW OPERATION:", name, "took", string.format("%.3f", elapsed).."s")
    end
    
    return elapsed
end

-- ========== Helpers & Safe API ==========
local Players        = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace      = game:GetService("Workspace")
local LocalPlayer    = Players.LocalPlayer

logInfo("INIT", "Starting FishItHub v3.5 with Enhanced Logging")

-- safe load ProjectMadara UI
local ProjectMadara
perfStart("LoadUI")
local ok, err = pcall(function()
    ProjectMadara = loadstring(game:HttpGet("https://raw.githubusercontent.com/idonthaveoneatm/Libraries/normal/quake/src"))()
end)
perfEnd("LoadUI")

if not ok or not ProjectMadara then
    logCritical("INIT", "Failed to load UI library:", tostring(err))
    return
end
logInfo("INIT", "UI library loaded successfully")

-- ========= Adaptive net detection =========
perfStart("FindNet")
local function findNet()
    logDebug("NET", "Searching for net package...")
    local pk = ReplicatedStorage:FindFirstChild("Packages")
    if not pk then 
        logWarn("NET", "Packages folder not found")
        return nil 
    end
    local idx = pk:FindFirstChild("_Index")
    if not idx then 
        logWarn("NET", "_Index folder not found")
        return nil 
    end
    for _, v in ipairs(idx:GetChildren()) do
        if type(v.Name) == "string" and string.find(v.Name, "sleitnick_net") then
            local net = v:FindFirstChild("net")
            if net then 
                logInfo("NET", "Found net in:", v.Name)
                return net 
            end
        end
    end
    logWarn("NET", "sleitnick_net not found in _Index")
    return nil
end

local net = findNet()
local tries = 0
while not net and tries < 15 do
    tries = tries + 1
    logWarn("NET", "Attempt", tries, "- net not found, waiting...")
    wait(1)
    net = findNet()
end
perfEnd("FindNet")

if not net then
    logCritical("NET", "Cannot locate sleitnick net package after", tries, "attempts. ABORTING.")
    return
end
logInfo("NET", "Net located at:", net:GetFullName())

-- determine RF/RE containers
local rf = net:FindFirstChild("RF") or net
local re = net:FindFirstChild("RE") or net
logInfo("NET", "Using RF container:", rf.Name, "RE container:", re.Name)

-- helper to find remote with detailed logging
local function findRemoteAny(name)
    logDebug("REMOTE", "Searching for:", name)
    
    -- Try exact in RF/RE
    local r = rf:FindFirstChild(name)
    if r then 
        logInfo("REMOTE", "Found in RF:", name)
        return r 
    end
    
    r = re:FindFirstChild(name)
    if r then 
        logInfo("REMOTE", "Found in RE:", name)
        return r 
    end
    
    -- Try with path prefix
    r = rf:FindFirstChild("RF/"..name)
    if r then 
        logInfo("REMOTE", "Found with RF/ prefix:", name)
        return r 
    end
    
    r = re:FindFirstChild("RE/"..name)
    if r then 
        logInfo("REMOTE", "Found with RE/ prefix:", name)
        return r 
    end
    
    -- Search descendants
    for _,v in ipairs(net:GetDescendants()) do
        if (v:IsA("RemoteFunction") or v:IsA("RemoteEvent")) and v.Name:lower():find(name:lower()) then
            logInfo("REMOTE", "Found via descendant search:", name, "at", v:GetFullName())
            return v
        end
    end
    
    logWarn("REMOTE", "NOT FOUND:", name)
    return nil
end

local function safeInvoke(remote, ...)
    if not remote then 
        logError("INVOKE", "Remote is nil")
        return false, "remote nil" 
    end
    
    logDebug("INVOKE", "Calling:", remote.Name)
    local ok, res = pcall(function() return remote:InvokeServer(...) end)
    
    if not ok then
        logError("INVOKE", "Failed:", remote.Name, "Error:", tostring(res))
    else
        logDebug("INVOKE", "Success:", remote.Name)
    end
    
    return ok, res
end

local function safeFire(remote, ...)
    if not remote then 
        logError("FIRE", "Remote is nil")
        return false, "remote nil" 
    end
    
    logDebug("FIRE", "Firing:", remote.Name)
    local ok, res = pcall(function() remote:FireServer(...) end)
    
    if not ok then
        logError("FIRE", "Failed:", remote.Name, "Error:", tostring(res))
    else
        logDebug("FIRE", "Success:", remote.Name)
    end
    
    return ok, res
end

-- ========== REMOTES ==========
perfStart("LoadRemotes")
logInfo("REMOTE", "Loading all remotes...")

local REMOTES = {
    ChargeFishingRod          = findRemoteAny("ChargeFishingRod"),
    RequestFishingMinigameStarted = findRemoteAny("RequestFishingMinigameStarted"),
    FishingCompleted          = findRemoteAny("FishingCompleted"),
    FishingMinigameChanged    = findRemoteAny("FishingMinigameChanged"),
    FishingStopped            = findRemoteAny("FishingStopped"),
    EquipToolFromHotbar       = findRemoteAny("EquipToolFromHotbar"),
    EquipBait                 = findRemoteAny("EquipBait"),
    SellAllItems              = findRemoteAny("SellAllItems"),
    SellItem                  = findRemoteAny("SellItem"),
    PurchaseBait              = findRemoteAny("PurchaseBait"),
    PurchaseFishingRod        = findRemoteAny("PurchaseFishingRod"),
    SpawnBoat                 = findRemoteAny("SpawnBoat"),
    DespawnBoat               = findRemoteAny("DespawnBoat"),
    UpdateAutoFishingState    = findRemoteAny("UpdateAutoFishingState"),
    RequestSpin               = findRemoteAny("RequestSpin"),
    ClaimDaily                = findRemoteAny("ClaimDailyLogin"),
    GetInventory              = findRemoteAny("GetInventory") or findRemoteAny("RequestInventory") or findRemoteAny("RequestPlayerInventory"),
}

perfEnd("LoadRemotes")

logInfo("REMOTE", "=== Remote Detection Summary ===")
local remoteCount = {found = 0, missing = 0}
for k,v in pairs(REMOTES) do 
    if v then
        remoteCount.found = remoteCount.found + 1
        logInfo("REMOTE", "âœ…", k)
    else
        remoteCount.missing = remoteCount.missing + 1
        logWarn("REMOTE", "âŒ", k, "- NOT FOUND")
    end
end
logInfo("REMOTE", "Found:", remoteCount.found, "Missing:", remoteCount.missing)

-- ========== SETTINGS ==========
local settings = {
    autoFish = false,
    catchMode = "Perfect",
    smartTiming = true,
    autoSellWhenFull = true,
    sellThreshold = 5000,
    protectRarities = { secret=true, mythic=true, legendary=true },
    autoReturnAfterSell = true,
    antiAFK = true,
    safeMode = false,
    heartbeatTimeout = 12,
    rareAlertEnabled = true,
}

local CATCH_TIMINGS = {
    Perfect = 0.85,
    Amazing = 0.6,
    Good = 0.35,
    Fast = 0.15,
}

-- ========== STATE ==========
local state = {
    running = false,
    lastActivity = tick(),
    fishingThread = nil,
    heartbeatThread = nil,
    savedFishingSpot = nil,
    lastSellSummary = nil,
    minigameActive = false,
    lastMinigameTs = 0,
    errorCount = {fishing = 0, selling = 0, teleport = 0, inventory = 0},
    lastError = {},
}

local function updateActivity()
    state.lastActivity = tick()
    logDebug("ACTIVITY", "Activity updated")
end

-- ========== UTILITY: Inventory ==========
local function getInventory()
    perfStart("GetInventory")
    logDebug("INVENTORY", "Attempting to fetch inventory...")
    
    local invRemote = REMOTES.GetInventory
    if not invRemote then
        logWarn("INVENTORY", "No inventory remote available")
        perfEnd("GetInventory")
        return nil
    end
    
    local ok, res = safeInvoke(invRemote)
    perfEnd("GetInventory")
    
    if ok and type(res) == "table" then
        logInfo("INVENTORY", "Retrieved", #res, "items")
        return res
    else
        logError("INVENTORY", "Failed to retrieve inventory:", tostring(res))
        state.errorCount.inventory = state.errorCount.inventory + 1
        state.lastError.inventory = {time = tick(), error = tostring(res)}
        return nil
    end
end

local function getInventoryCount()
    perfStart("GetInventoryCount")
    local inv = getInventory()
    if not inv then 
        perfEnd("GetInventoryCount")
        return nil 
    end
    
    local count = 0
    for _, item in ipairs(inv) do
        if type(item) == "table" then
            count = count + (item.count or 1)
        else
            count = count + 1
        end
    end
    
    logInfo("INVENTORY", "Total count:", count)
    perfEnd("GetInventoryCount")
    return count
end

local function inventoryHasProtected()
    local inv = getInventory()
    if not inv then return nil end
    
    for _, item in ipairs(inv) do
        local rarity = (item.rarity or ""):lower()
        if settings.protectRarities[rarity] then
            logInfo("INVENTORY", "Found protected item:", item.name or "unknown", "rarity:", rarity)
            return true, item
        end
    end
    return false
end

-- ========== RARE ALERT ==========
local function isRareByNameOrRarity(item)
    if not item then return false end
    if type(item) == "table" then
        local r = tostring(item.rarity or ""):lower()
        if settings.protectRarities[r] then return true end
        local name = tostring(item.name or ""):lower()
        if name:find("secret") or name:find("mythic") or name:find("legend") then return true end
    elseif type(item) == "string" then
        local n = item:lower()
        if n:find("secret") or n:find("mythic") or n:find("legendary") then return true end
    end
    return false
end

local function rareAlert(item)
    if not settings.rareAlertEnabled then return end
    logInfo("RARE", "ðŸ”¥ RARE CATCH DETECTED:", item and (type(item)=="table" and (item.name or "item") or tostring(item)))
    
    pcall(function()
        local dsp = findRemoteAny("DisplaySystemMessage")
        if dsp then
            pcall(function() dsp:FireServer("Rare catch detected! Check inventory", {duration=5}) end)
        end
    end)
end

-- ========== FISHING CORE ==========
local function attemptCastAndCatchCycle()
    perfStart("FishingCycle")
    logInfo("FISHING", "=== Starting Fishing Cycle ===")
    updateActivity()
    
    -- Step 1: Equip tool
    logDebug("FISHING", "Step 1: Equipping tool...")
    if REMOTES.EquipToolFromHotbar then
        local ok = pcall(function()
            safeFire(REMOTES.EquipToolFromHotbar, 1)
        end)
        if not ok then
            logError("FISHING", "Failed to equip tool")
            state.errorCount.fishing = state.errorCount.fishing + 1
        else
            logInfo("FISHING", "Tool equipped")
        end
    else
        logWarn("FISHING", "EquipToolFromHotbar remote not available")
    end

    -- Wait
    local waitTime = settings.safeMode and 1.0 or 0.45
    logDebug("FISHING", "Waiting", waitTime, "seconds...")
    wait(waitTime)

    -- Step 2: Charge/Cast
    logDebug("FISHING", "Step 2: Charging fishing rod...")
    if REMOTES.ChargeFishingRod then
        local ok, res = safeInvoke(REMOTES.ChargeFishingRod, Workspace:GetServerTimeNow())
        if not ok then
            logError("FISHING", "ChargeFishingRod failed:", tostring(res))
            state.errorCount.fishing = state.errorCount.fishing + 1
            state.lastError.fishing = {time = tick(), step = "charge", error = tostring(res)}
        else
            logInfo("FISHING", "Rod charged successfully")
        end
    else
        logError("FISHING", "ChargeFishingRod remote not found - CRITICAL")
    end

    -- Step 3: Smart timing wait
    logDebug("FISHING", "Step 3: Calculating timing...")
    if settings.smartTiming and state.minigameActive then
        local offset = CATCH_TIMINGS[settings.catchMode] or 0.6
        local elapsed = tick() - state.lastMinigameTs
        if elapsed < 5 then
            local waitFor = math.max(0.05, offset - (elapsed*0.2))
            logInfo("FISHING", "Smart timing: waiting", string.format("%.2f", waitFor), "seconds")
            wait(waitFor)
        else
            logDebug("FISHING", "Using default timing:", offset)
            wait(offset)
        end
    else
        local timing = CATCH_TIMINGS[settings.catchMode] or 0.6
        logDebug("FISHING", "Using catch mode timing:", settings.catchMode, "=", timing)
        wait(timing)
    end

    -- Step 4: Request minigame
    logDebug("FISHING", "Step 4: Requesting minigame start...")
    if REMOTES.RequestFishingMinigameStarted then
        pcall(function()
            safeInvoke(REMOTES.RequestFishingMinigameStarted, -1.2379, 1)
            logDebug("FISHING", "Minigame start requested")
        end)
    end

    -- Step 5: Final wait
    local finalDelay = CATCH_TIMINGS[settings.catchMode] or 0.6
    if settings.safeMode then finalDelay = finalDelay + 0.5 end
    logDebug("FISHING", "Step 5: Final wait:", string.format("%.2f", finalDelay), "seconds")
    wait(finalDelay)

    -- Step 6: Complete catch
    logDebug("FISHING", "Step 6: Completing catch...")
    if REMOTES.FishingCompleted then
        local ok, res = safeFire(REMOTES.FishingCompleted)
        if not ok then
            logError("FISHING", "FishingCompleted failed:", tostring(res))
            state.errorCount.fishing = state.errorCount.fishing + 1
            state.lastError.fishing = {time = tick(), step = "complete", error = tostring(res)}
        else
            logInfo("FISHING", "âœ… Catch completed successfully")
            if ok and res and isRareByNameOrRarity(res) then
                rareAlert(res)
            end
        end
    else
        logError("FISHING", "FishingCompleted remote not found - CRITICAL")
    end
    
    updateActivity()
    local duration = perfEnd("FishingCycle")
    logInfo("FISHING", "=== Cycle Complete === Duration:", string.format("%.2f", duration or 0), "seconds")
end

-- fishing control thread
local function startAutoFishing()
    if state.fishingThread then 
        logWarn("FISHING", "Thread already running")
        return 
    end
    
    logInfo("FISHING", "ðŸŽ£ Starting AutoFishing thread...")
    state.running = true
    state.fishingThread = spawn(function()
        local cycleCount = 0
        
        while state.running and settings.autoFish do
            cycleCount = cycleCount + 1
            logInfo("FISHING", ">>> Cycle", cycleCount, "starting...")
            
            local ok, err = pcall(function()
                attemptCastAndCatchCycle()
            end)
            
            if not ok then
                logError("FISHING", "Cycle", cycleCount, "crashed:", tostring(err))
                state.errorCount.fishing = state.errorCount.fishing + 1
                state.lastError.fishing = {time = tick(), cycle = cycleCount, error = tostring(err)}
            end
            
            -- between cycles
            local betweenWait = settings.safeMode and 2.5 or 1.8
            logDebug("FISHING", "Waiting", betweenWait, "seconds before next cycle...")
            wait(betweenWait)
        end
        
        logInfo("FISHING", "AutoFishing thread stopped after", cycleCount, "cycles")
        state.fishingThread = nil
    end)
end

local function stopAutoFishing()
    logInfo("FISHING", "ðŸ›‘ Stopping AutoFishing...")
    state.running = false
    settings.autoFish = false
end

-- ========== AUTO SELL ==========
local function doSellAllBestEffort()
    perfStart("Sell")
    logInfo("SELL", "=== Starting Sell Process ===")
    
    local inv = getInventory()
    if inv then
        logInfo("SELL", "Inventory has", #inv, "items")
        
        local sellCandidates = {}
        local protectedCount = 0
        
        for _, item in ipairs(inv) do
            local r = (item.rarity or ""):lower()
            if not settings.protectRarities[r] then
                table.insert(sellCandidates, item)
            else
                protectedCount = protectedCount + 1
                logInfo("SELL", "Protected item:", item.name or "unknown", "rarity:", r)
            end
        end
        
        logInfo("SELL", "Sellable:", #sellCandidates, "Protected:", protectedCount)
        
        if #sellCandidates == 0 then
            logWarn("SELL", "No sellable items (all protected)")
            perfEnd("Sell")
            return false, "no sellable items"
        end
        
        if REMOTES.SellItem then
            logInfo("SELL", "Using per-item sell method...")
            local soldCount, earned = 0, 0
            
            for i, it in ipairs(sellCandidates) do
                logDebug("SELL", "Selling item", i, "of", #sellCandidates)
                local ok, res = safeInvoke(REMOTES.SellItem, it.id or it.name or it)
                
                if ok then
                    soldCount = soldCount + (it.count or 1)
                    earned = earned + (res and (res.amount or 0) or 0)
                    logDebug("SELL", "Sold item", i)
                else
                    logError("SELL", "Failed to sell item", i, ":", tostring(res))
                    state.errorCount.selling = state.errorCount.selling + 1
                end
                wait(0.15)
            end
            
            state.lastSellSummary = {count = soldCount, earned = earned}
            logInfo("SELL", "âœ… Sold", soldCount, "items for", earned, "coins")
            perfEnd("Sell")
            return true, state.lastSellSummary
        end
        
        if REMOTES.SellAllItems then
            logWarn("SELL", "Using SellAllItems (may sell protected items)")
            local ok,res = safeInvoke(REMOTES.SellAllItems)
            state.lastSellSummary = {raw = res}
            perfEnd("Sell")
            return ok, res
        end
        
        logError("SELL", "No suitable sell remote found")
        perfEnd("Sell")
        return false, "no suitable sell remote"
    else
        logError("SELL", "Cannot access inventory")
        if REMOTES.SellAllItems then
            logWarn("SELL", "No inventory info - refusing auto-sell to protect rarities")
            perfEnd("Sell")
            return false, "no-inventory"
        end
        perfEnd("Sell")
        return false, "no-sell-remote"
    end
end

-- Auto-sell watcher
local function autoSellWatcher()
    logInfo("SELL", "Starting auto-sell watcher thread...")
    spawn(function()
        local checkCount = 0
        while true do
            checkCount = checkCount + 1
            
            if settings.autoSellWhenFull then
                logDebug("SELL", "Check", checkCount, "- Checking inventory threshold...")
                local count = getInventoryCount()
                
                if count then
                    logDebug("SELL", "Inventory count:", count, "/ Threshold:", settings.sellThreshold)
                    
                    if count >= settings.sellThreshold then
                        logInfo("SELL", "ðŸ”” Threshold reached! Attempting auto-sell...")
                        local ok, res = doSellAllBestEffort()
                        
                        if ok then
                            logInfo("SELL", "Auto-sell completed:", res)
                            
                            if settings.autoReturnAfterSell and state.savedFishingSpot then
                                logInfo("SELL", "Returning to saved fishing spot...")
                                local char = workspace:FindFirstChild("Characters") and workspace.Characters:FindFirstChild(LocalPlayer.Name)
                                if char and char:FindFirstChild("HumanoidRootPart") then
                                    char.HumanoidRootPart.CFrame = state.savedFishingSpot
                                    logInfo("SELL", "âœ… Returned to fishing spot")
                                else
                                    logError("SELL", "Cannot find character for return teleport")
                                end
                            end
                        else
                            logError("SELL", "Auto-sell failed:", tostring(res))
                            state.errorCount.selling = state.errorCount.selling + 1
                            state.lastError.selling = {time = tick(), error = tostring(res)}
                        end
                    end
                else
                    logWarn("SELL", "Cannot get inventory count")
                end
            end
            
            wait(5)
        end
    end)
end

-- ========== TELEPORTS ==========
local TELEPORTS = {
    NPCs = {
        ["Rods Here"] = nil, ["Bobbers"] = nil, ["Skin Crates"] = nil,
        ["Sell Here!"] = nil, ["Utility Store"] = nil, ["Spin Wheel"] = nil,
        ["Traveling Merchant"] = nil,
    },
    Islands = {
        ["Crater Island"] = nil, ["Tropical Grove"] = nil, ["Coral Reefs"] = nil,
        ["Weather Machine"] = nil, ["Lost Isle"] = nil, ["Kohana"] = nil,
        ["Kohana Volcano"] = nil, ["Esoteric Depths"] = nil,
    }
}

local function scanAndPopulateTeleports()
    perfStart("TeleportScan")
    logInfo("TELEPORT", "Starting world scan for teleport targets...")
    
    local foundCount = 0
    for key,_ in pairs(TELEPORTS.NPCs) do TELEPORTS.NPCs[key] = nil end
    for key,_ in pairs(TELEPORTS.Islands) do TELEPORTS.Islands[key] = nil end

    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") or obj:IsA("Model") then
            local name = tostring(obj.Name):lower()
            
            for key,_ in pairs(TELEPORTS.NPCs) do
                if name:find(key:lower():gsub("%s","")) or name:find(key:lower():sub(1,6)) then
                    local pos = (obj:IsA("BasePart") and obj.Position) or (obj:IsA("Model") and (obj:FindFirstChild("PrimaryPart") and obj.PrimaryPart.Position or (obj:FindFirstChildWhichIsA("BasePart") and obj:FindFirstChildWhichIsA("BasePart").Position)))
                    if pos and not TELEPORTS.NPCs[key] then 
                        TELEPORTS.NPCs[key] = pos 
                        logInfo("TELEPORT", "Found NPC:", key)
                        foundCount = foundCount + 1
                    end
                end
            end
            
            for key,_ in pairs(TELEPORTS.Islands) do
                if name:find(key:lower():gsub("%s","")) or name:find(key:lower():sub(1,6)) then
                    local pos = (obj:IsA("BasePart") and obj.Position) or (obj:IsA("Model") and (obj:FindFirstChild("PrimaryPart") and obj.PrimaryPart.Position or (obj:FindFirstChildWhichIsA("BasePart") and obj:FindFirstChildWhichIsA("BasePart").Position)))
                    if pos and not TELEPORTS.Islands[key] then 
                        TELEPORTS.Islands[key] = pos 
                        logInfo("TELEPORT", "Found Island:", key)
                        foundCount = foundCount + 1
                    end
                end
            end
        end
    end
    
    perfEnd("TeleportScan")
    logInfo("TELEPORT", "Scan complete. Found", foundCount, "locations")
end

local function teleportToPos(pos)
    perfStart("Teleport")
    logDebug("TELEPORT", "Attempting teleport to:", tostring(pos))
    
    local char = workspace:FindFirstChild("Characters") and workspace.Characters:FindFirstChild(LocalPlayer.Name)
    if not char then 
        logError("TELEPORT", "Character not found")
        state.errorCount.teleport = state.errorCount.teleport + 1
        perfEnd("Teleport")
        return false 
    end
    
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then 
        logError("TELEPORT", "HumanoidRootPart not found")
        state.errorCount.teleport = state.errorCount.teleport + 1
        perfEnd("Teleport")
        return false 
    end
    
    hrp.CFrame = CFrame.new(pos + Vector3.new(0,3,0))
    updateActivity()
    logInfo("TELEPORT", "âœ… Teleported successfully")
    perfEnd("Teleport")
    return true
end

-- ========== ANTI AFK & HEARTBEAT ==========
local function setupAntiAFK()
    logInfo("ANTIALERT", "Setting up Anti-AFK...")
    pcall(function()
        LocalPlayer.Idled:Connect(function()
            logWarn("ANTIAFK", "Idle detected! Performing anti-AFK action...")
            local ok2, vu = pcall(function() return game:GetService("VirtualUser") end)
            if ok2 and vu then
                vu:CaptureController()
                vu:ClickButton2(Vector2.new(0,0))
                logInfo("ANTIAFK", "VirtualUser click performed")
            else
                pcall(function()
                    local cam = workspace.CurrentCamera
                    if cam then
                        cam.CFrame = cam.CFrame * CFrame.Angles(0,0.01,0)
                        logInfo("ANTIAFK", "Camera nudge performed")
                    end
                end)
            end
        end)
        logInfo("ANTIAFK", "âœ… Anti-AFK setup complete")
    end)
end

local function attemptReconnect()
    perfStart("Reconnect")
    logWarn("RECONNECT", "Attempting to reconnect/rescan remotes...")
    
    net = findNet() or net
    rf = net:FindFirstChild("RF") or net
    re = net:FindFirstChild("RE") or net
    
    logInfo("RECONNECT", "Refreshing critical remotes...")
    REMOTES.ChargeFishingRod = findRemoteAny("ChargeFishingRod")
    REMOTES.FishingCompleted = findRemoteAny("FishingCompleted")
    REMOTES.EquipToolFromHotbar = findRemoteAny("EquipToolFromHotbar")
    REMOTES.SellAllItems = findRemoteAny("SellAllItems")
    REMOTES.SellItem = findRemoteAny("SellItem")
    REMOTES.GetInventory = findRemoteAny("GetInventory") or findRemoteAny("RequestInventory")
    
    perfEnd("Reconnect")
    logInfo("RECONNECT", "âœ… Reconnect complete")
end

local function startHeartbeat()
    if state.heartbeatThread then 
        logWarn("HEARTBEAT", "Thread already running")
        return 
    end
    
    logInfo("HEARTBEAT", "Starting heartbeat watchdog...")
    state.heartbeatThread = spawn(function()
        local checkCount = 0
        
        while true do
            checkCount = checkCount + 1
            local last = state.lastActivity or tick()
            local elapsed = tick() - last
            
            logDebug("HEARTBEAT", "Check", checkCount, "- Last activity:", string.format("%.1f", elapsed), "seconds ago")
            
            if elapsed > settings.heartbeatTimeout then
                logWarn("HEARTBEAT", "â° TIMEOUT DETECTED! Elapsed:", string.format("%.1f", elapsed), "seconds")
                
                pcall(function()
                    logInfo("HEARTBEAT", "Stopping current fishing thread...")
                    state.running = false
                    wait(0.5)
                    
                    logInfo("HEARTBEAT", "Attempting reconnect...")
                    attemptReconnect()
                    
                    if settings.autoFish then
                        logInfo("HEARTBEAT", "Restarting auto-fish...")
                        state.running = true
                        startAutoFishing()
                        logInfo("HEARTBEAT", "âœ… Auto-fish restarted")
                    end
                end)
                updateActivity()
            end
            
            wait(math.max(1, settings.heartbeatTimeout/2))
        end
    end)
end

-- ========== GUI CREATION ==========
logInfo("GUI", "Creating GUI interface...")
perfStart("CreateGUI")

local Main = ProjectMadara:Window({ Title = "FishItHub v3.5 Ultimate [Enhanced Logging]" })

local T_fish = Main:Tab({ Name = "Fishing", tabColor = Color3.fromHex("#3CB371"), Image = "rbxassetid://10709769841" })
local T_sell = Main:Tab({ Name = "Sell", tabColor = Color3.fromHex("#FFD700"), Image = "rbxassetid://10734952479" })
local T_travel = Main:Tab({ Name = "Travel", tabColor = Color3.fromHex("#1E90FF"), Image = "rbxassetid://10734886202" })
local T_settings = Main:Tab({ Name = "Settings", tabColor = Color3.fromHex("#FFA500"), Image = "rbxassetid://10734886202" })
local T_debug = Main:Tab({ Name = "Debug", tabColor = Color3.fromHex("#BA55D3"), Image = "rbxassetid://10747347376" })
local T_logs = Main:Tab({ Name = "Logs", tabColor = Color3.fromHex("#FF6347"), Image = "rbxassetid://10747347376" })

-- Fishing tab
T_fish:Label("ðŸŽ£ Core Fishing")
T_fish:Toggle({ Name = "Auto Cast & Catch", Default = false, Callback = function(v)
    logInfo("GUI", "Auto Fish toggled:", v)
    settings.autoFish = v
    if v then startAutoFishing() end
end})

T_fish:Dropdown({ Name = "Catch Accuracy Mode", Default = "Perfect", Options = {"Perfect","Amazing","Good","Fast"}, Callback = function(opt)
    logInfo("GUI", "Catch mode changed to:", opt)
    settings.catchMode = opt
end})

T_fish:Toggle({ Name = "Smart Cast Timing", Default = true, Callback = function(v) 
    logInfo("GUI", "Smart Timing:", v)
    settings.smartTiming = v 
end })

T_fish:Toggle({ Name = "Safe Mode (slow)", Default = false, Callback = function(v) 
    logInfo("GUI", "Safe Mode:", v)
    settings.safeMode = v 
end })

T_fish:Button({ Name = "Stop AutoFishing", Callback = function() 
    stopAutoFishing() 
end })

T_fish:Label("Fishing Spot")
T_fish:Button({ Name = "Save Current Spot", Callback = function()
    logInfo("GUI", "Saving fishing spot...")
    local char = workspace:FindFirstChild("Characters") and workspace.Characters:FindFirstChild(LocalPlayer.Name)
    if not char then return logError("GUI", "Character not found") end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return logError("GUI", "HRP not found") end
    state.savedFishingSpot = hrp.CFrame
    logInfo("GUI", "âœ… Fishing spot saved")
end})

T_fish:Button({ Name = "Teleport to Saved Spot", Callback = function()
    if not state.savedFishingSpot then return logWarn("GUI", "No saved fishing spot") end
    logInfo("GUI", "Teleporting to saved spot...")
    local char = workspace:FindFirstChild("Characters") and workspace.Characters:FindFirstChild(LocalPlayer.Name)
    if not char then return logError("GUI", "Character not found") end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return logError("GUI", "HRP not found") end
    hrp.CFrame = state.savedFishingSpot
    logInfo("GUI", "âœ… Teleported to saved spot")
end})

-- Sell tab
T_sell:Label("ðŸ’° Sell Controls")
T_sell:Toggle({ Name = "Auto Sell When Full (threshold 5000)", Default = true, Callback = function(v) 
    logInfo("GUI", "Auto Sell When Full:", v)
    settings.autoSellWhenFull = v 
end })

T_sell:Button({ Name = "Manual Sell Now", Callback = function()
    logInfo("GUI", "Manual sell requested")
    local ok,res = doSellAllBestEffort()
    logInfo("GUI", "Manual sell result:", ok, res)
end})

T_sell:Toggle({ Name = "Return to Spot After Sell", Default = true, Callback = function(v) 
    logInfo("GUI", "Return After Sell:", v)
    settings.autoReturnAfterSell = v 
end })

T_sell:Label("Protect rarities from selling:")
T_sell:Toggle({ Name = "Protect Secret/Mythic/Legendary", Default = true, Callback = function(v)
    logInfo("GUI", "Protect Rarities:", v)
    if v then
        settings.protectRarities.secret = true
        settings.protectRarities.mythic = true
        settings.protectRarities.legendary = true
    else
        settings.protectRarities.secret = false
        settings.protectRarities.mythic = false
        settings.protectRarities.legendary = false
    end
end})

-- Travel tab
T_travel:Label("ðŸ“ Teleport")
T_travel:Button({ Name = "Scan World for NPCs & Islands", Callback = function()
    logInfo("GUI", "Starting teleport scan...")
    scanAndPopulateTeleports()
    logInfo("GUI", "Scan complete")
end})

for name,_ in pairs(TELEPORTS.NPCs) do
    local n = name
    T_travel:Button({ Name = "TP NPC: "..n, Callback = function()
        if not TELEPORTS.NPCs[n] then 
            logWarn("GUI", "No target found for NPC:", n)
            return 
        end
        logInfo("GUI", "Teleporting to NPC:", n)
        teleportToPos(TELEPORTS.NPCs[n])
    end})
end

for name,_ in pairs(TELEPORTS.Islands) do
    local n = name
    T_travel:Button({ Name = "TP Island: "..n, Callback = function()
        if not TELEPORTS.Islands[n] then 
            logWarn("GUI", "No target found for Island:", n)
            return 
        end
        logInfo("GUI", "Teleporting to Island:", n)
        teleportToPos(TELEPORTS.Islands[n])
    end})
end

-- Settings tab
T_settings:Label("âš™ï¸ Settings & Protection")
T_settings:Toggle({ Name = "Anti-AFK", Default = true, Callback = function(v) 
    logInfo("GUI", "Anti-AFK:", v)
    settings.antiAFK = v
    if v then setupAntiAFK() end
end })

T_settings:Toggle({ Name = "Safe Mode", Default = false, Callback = function(v) 
    logInfo("GUI", "Safe Mode:", v)
    settings.safeMode = v 
end })

T_settings:Slider({ Name = "Heartbeat Timeout (s)", Min = 6, Max = 30, Default = settings.heartbeatTimeout, Callback = function(v) 
    logInfo("GUI", "Heartbeat Timeout:", v)
    settings.heartbeatTimeout = v 
end})

T_settings:Button({ Name = "Force Reconnect", Callback = function() 
    logInfo("GUI", "Manual reconnect triggered")
    attemptReconnect() 
end})

-- Debug tab
T_debug:Label("ðŸ§¾ Debug Console")
T_debug:Button({ Name = "Show Error Summary", Callback = function()
    logInfo("DEBUG", "=== ERROR SUMMARY ===")
    logInfo("DEBUG", "Fishing errors:", state.errorCount.fishing)
    logInfo("DEBUG", "Selling errors:", state.errorCount.selling)
    logInfo("DEBUG", "Teleport errors:", state.errorCount.teleport)
    logInfo("DEBUG", "Inventory errors:", state.errorCount.inventory)
    
    if state.lastError.fishing then
        logInfo("DEBUG", "Last fishing error:", state.lastError.fishing.error, "at step:", state.lastError.fishing.step or "unknown")
    end
    if state.lastError.selling then
        logInfo("DEBUG", "Last selling error:", state.lastError.selling.error)
    end
end})

T_debug:Button({ Name = "Show Performance Stats", Callback = function()
    logInfo("DEBUG", "=== PERFORMANCE STATS ===")
    for name, data in pairs(perfTracker) do
        local avg = data.totalTime and data.count > 0 and (data.totalTime / data.count) or 0
        logInfo("DEBUG", name..":", "Count:", data.count, "Avg:", string.format("%.3f", avg).."s", "Last:", string.format("%.3f", data.lastDuration or 0).."s")
    end
end})

T_debug:Button({ Name = "Copy Remote List", Callback = function()
    local lines = {}
    for _,v in ipairs(net:GetDescendants()) do
        if v:IsA("RemoteEvent") or v:IsA("RemoteFunction") then
            table.insert(lines, tostring(v.ClassName).." : "..v:GetFullName())
        end
    end
    local txt = table.concat(lines, "\n")
    if setclipboard then 
        setclipboard(txt)
        logInfo("DEBUG", "Remote list copied to clipboard")
    else 
        logWarn("DEBUG", "setclipboard not supported")
    end
end})

T_debug:Button({ Name = "Show Last Sell Summary", Callback = function()
    if state.lastSellSummary then
        logInfo("DEBUG", "Last Sell:", "Count:", state.lastSellSummary.count or "N/A", "Earned:", state.lastSellSummary.earned or "N/A")
    else
        logInfo("DEBUG", "No sell data available")
    end
end})

T_debug:Button({ Name = "Start Heartbeat Watchdog", Callback = function() 
    startHeartbeat()
end })

-- Logs tab - NEW!
T_logs:Label("ðŸ“‹ Live Log Viewer")
T_logs:Button({ Name = "Show Last 20 Logs", Callback = function()
    logInfo("LOGS", "=== LAST 20 LOGS ===")
    local start = math.max(1, #logHistory - 19)
    for i = start, #logHistory do
        local entry = logHistory[i]
        print(string.format("[%s][%s] %s", entry.time, entry.category, entry.message))
    end
end})

T_logs:Button({ Name = "Show ERROR Logs Only", Callback = function()
    logInfo("LOGS", "=== ERROR LOGS ===")
    local errorCount = 0
    for _, entry in ipairs(logHistory) do
        if entry.level >= LOG_LEVELS.ERROR then
            print(string.format("[%s][%s] %s", entry.time, entry.category, entry.message))
            errorCount = errorCount + 1
        end
    end
    logInfo("LOGS", "Total errors found:", errorCount)
end})

T_logs:Button({ Name = "Show FISHING Logs Only", Callback = function()
    logInfo("LOGS", "=== FISHING LOGS ===")
    for _, entry in ipairs(logHistory) do
        if entry.category == "FISHING" then
            print(string.format("[%s] %s", entry.time, entry.message))
        end
    end
end})

T_logs:Button({ Name = "Show SELL Logs Only", Callback = function()
    logInfo("LOGS", "=== SELL LOGS ===")
    for _, entry in ipairs(logHistory) do
        if entry.category == "SELL" or entry.category == "INVENTORY" then
            print(string.format("[%s][%s] %s", entry.time, entry.category, entry.message))
        end
    end
end})

T_logs:Button({ Name = "Clear Log History", Callback = function()
    logHistory = {}
    logInfo("LOGS", "Log history cleared")
end})

T_logs:Label("Log Level Filter:")
T_logs:Dropdown({ Name = "Set Log Level", Default = "DEBUG", Options = {"DEBUG", "INFO", "WARN", "ERROR", "CRITICAL"}, Callback = function(opt)
    if opt == "DEBUG" then currentLogLevel = LOG_LEVELS.DEBUG
    elseif opt == "INFO" then currentLogLevel = LOG_LEVELS.INFO
    elseif opt == "WARN" then currentLogLevel = LOG_LEVELS.WARN
    elseif opt == "ERROR" then currentLogLevel = LOG_LEVELS.ERROR
    elseif opt == "CRITICAL" then currentLogLevel = LOG_LEVELS.CRITICAL
    end
    logInfo("LOGS", "Log level set to:", opt)
end})

T_logs:Button({ Name = "Export Logs to Clipboard", Callback = function()
    local lines = {}
    for _, entry in ipairs(logHistory) do
        local levelName = "DEBUG"
        for k,v in pairs(LOG_LEVELS) do
            if v == entry.level then levelName = k; break end
        end
        table.insert(lines, string.format("[%s][%s][%s] %s", entry.time, levelName, entry.category, entry.message))
    end
    local txt = table.concat(lines, "\n")
    if setclipboard then 
        setclipboard(txt)
        logInfo("LOGS", "Logs exported to clipboard -", #logHistory, "entries")
    else 
        logWarn("LOGS", "setclipboard not supported")
    end
end})

perfEnd("CreateGUI")
logInfo("GUI", "âœ… GUI created successfully")

-- ========== START SERVICES ==========
logInfo("INIT", "Starting services...")

if settings.antiAFK then 
    setupAntiAFK() 
end

autoSellWatcher()
startHeartbeat()

logInfo("INIT", "âœ…âœ…âœ… FishItHub v3.5 FULLY LOADED âœ…âœ…âœ…")
logInfo("INIT", "Use GUI to control features")
logInfo("INIT", "Check 'Logs' tab for detailed monitoring")
logInfo("INIT", "Check 'Debug' tab for error summary and performance stats")

-- END OF SCRIPT
